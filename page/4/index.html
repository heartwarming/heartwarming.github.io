<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-深入理解 React JS 中的 setState" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20React%20JS%20%E4%B8%AD%E7%9A%84%20setState/" class="article-date">
  <time class="dt-published" datetime="2019-05-15T10:10:11.000Z" itemprop="datePublished">2019-05-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20React%20JS%20%E4%B8%AD%E7%9A%84%20setState/">深入理解 React JS 中的 setState</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="深入理解-React-JS-中的-setState"><a href="#深入理解-React-JS-中的-setState" class="headerlink" title="深入理解 React JS 中的 setState"></a>深入理解 React JS 中的 setState</h1><p><img src="/images/react_4.png"></p>
<p>此文主要探讨了 React JS 中的 setState 背后的机制，供深入学习 React 研究之用。</p>
<h2 id="setState-的-“怪异”"><a href="#setState-的-“怪异”" class="headerlink" title="setState()的 “怪异”"></a>setState()的 “怪异”</h2><p>我们看下面一段简单的代码，代码通过点击一个按钮，改变 state 中的 clicked 值。在修改值后进行 clicked 值的输出，你尝试猜测一下输出的值是什么？</p>
<p><img src="/images/react_5.png"></p>
<p>我们在自己写代码遇到类似逻辑的时候都会发现，console.log(this.state.clicked); 这段代码输出的不是我们预期的 true，而是 false。</p>
<p>这是为什么呢？</p>
<h2 id="setState-的内部机制"><a href="#setState-的内部机制" class="headerlink" title="setState 的内部机制"></a>setState 的内部机制</h2><p>遇到问题我们还是去官方文档找线索。<br>我们看到 state 的章节有下面这段话。</p>
<p><img src="/images/react_6.png"></p>
<p><a target="_blank" rel="noopener" href="https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous">文章链接在这里</a></p>
<p>我们会发现其实 React 的 setState 方法是一个异步的方法，React 会将所有的 setState 方法打包成一次进行更新，类似于快递点寄快递，囤积了一些包裹后一次投递，而不是你每次修改 state 都会进行更新。<br>这样的设计主要是为了提高 UI 更新的性能，我们知道 React 中 state 的改变会导致 UI 的更新。<br>如果需要进行同步操作逻辑，那么在回调函数里添加逻辑即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleClick = () =&gt; &#123;</span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    clicked: true</span><br><span class="line">  &#125;, () =&gt; console.log(this.state.clicked)) //这时候输出的是 true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="state-的更新时机"><a href="#state-的更新时机" class="headerlink" title="state 的更新时机"></a>state 的更新时机</h2><p>任何 state 的更新都会导致 React 进行重新渲染。props 也会导致 React 进行重新渲染。组件与父组件的更改同样也会引起 React 的重新渲染。<br>那么我们有没有办法手动控制 React 是否进行渲染呢？<br>这里，你应该想起来生命周期函数里有一个方法 shouldComponentUpdate。</p>
<p><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate">shouldComponentUpdate 方法官方文档</a></p>
<p>此方法默认每次在需要进行重新渲染时返回 true，但是在这个函数里你可以添加自己的逻辑，控制 React 不进行渲染以及渲染的条件。<br>那么，同样，我们也可以在此函数中定义那些我们关注的 state ，只有当它们变化才让 React 进行重新渲染，而其他一些不相关的 state 的值即使变化了，我们也可以让 React 不进行渲染。<br>理解了这些，那么在你进行相关性能优化时就非常有用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20React%20JS%20%E4%B8%AD%E7%9A%84%20setState/" data-id="ckw8thukq0032e4d8ak0ihsy6" data-title="深入理解 React JS 中的 setState" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript语言编程规范(ES6)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/14/JavaScript%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83(ES6)/" class="article-date">
  <time class="dt-published" datetime="2019-05-13T23:20:13.000Z" itemprop="datePublished">2019-05-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/14/JavaScript%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83(ES6)/">JavaScript语言编程规范(ES6)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本篇博文参考Airbnb规范制定,有错误或不当请您务必指出</p>
</blockquote>
<h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><h2 id="导出的默认函数使用驼峰命名、文件名与函数完全一致。"><a href="#导出的默认函数使用驼峰命名、文件名与函数完全一致。" class="headerlink" title="导出的默认函数使用驼峰命名、文件名与函数完全一致。"></a>导出的默认函数使用驼峰命名、文件名与函数完全一致。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function makeStyleGuide()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">export default makeStyleGuide;</span><br></pre></td></tr></table></figure>

<h2 id="导出单例、函数库、空对象时使用帕斯卡式命名（帕斯卡式命名法是在命名的时候将首字母大写-如：-DisplayInfo）。"><a href="#导出单例、函数库、空对象时使用帕斯卡式命名（帕斯卡式命名法是在命名的时候将首字母大写-如：-DisplayInfo）。" class="headerlink" title="导出单例、函数库、空对象时使用帕斯卡式命名（帕斯卡式命名法是在命名的时候将首字母大写, 如： DisplayInfo）。"></a>导出单例、函数库、空对象时使用帕斯卡式命名（帕斯卡式命名法是在命名的时候将首字母大写, 如： DisplayInfo）。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const AirbnbStyleGuide = &#123;</span><br><span class="line">    es6: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">export default AirbnbStyleGuide</span><br></pre></td></tr></table></figure>

<h1 id="类型和变量"><a href="#类型和变量" class="headerlink" title="类型和变量"></a>类型和变量</h1><h2 id="变星必须显式声明作用域"><a href="#变星必须显式声明作用域" class="headerlink" title="变星必须显式声明作用域"></a>变星必须显式声明作用域</h2><ul>
<li>var =&gt; 用于声明全局变量或函数级变量</li>
<li>let  =&gt; 用于声明块级的局部变量</li>
<li>const =&gt; 声明块级域的只读局部变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const names = [];</span><br><span class="line">names.push(&#x27;john&#x27;);</span><br><span class="line">console.log(names);</span><br><span class="line">// 变量名字在内存中的指针不能够改变， 但是指向这个变量的值可能改变。</span><br><span class="line">name = [] // ERROR</span><br><span class="line">&#123;</span><br><span class="line">    let name;</span><br><span class="line">    name = &#x27;tom&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ES6中， const代表一个值的“常量索引”， 换句话说， 变量名字在内存中的指针不能够改变， 但是指向这个变量的值可能改变。</p>
<h2 id="尽量对所有的引用使用const，-不要使用var。-如果你一定需要使用可变动的引用，-使用let代替var。"><a href="#尽量对所有的引用使用const，-不要使用var。-如果你一定需要使用可变动的引用，-使用let代替var。" class="headerlink" title="尽量对所有的引用使用const， 不要使用var。 如果你一定需要使用可变动的引用， 使用let代替var。"></a>尽量对所有的引用使用const， 不要使用var。 如果你一定需要使用可变动的引用， 使用let代替var。</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a=1;</span><br><span class="line">var count=1;</span><br><span class="line">if(true)&#123;</span><br><span class="line">    count+=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a=1;</span><br><span class="line">let count=1;</span><br><span class="line">if(true)&#123;</span><br><span class="line">    count+=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：const和let的作用域更小， 写代码更容易控制。 const可确保无法对引用重新赋值， const引用的指针不变， 重新赋值会报错， 避免不小心的重新赋值给覆盖了。</p>
<h2 id="将所有的const和let分组-并隔行"><a href="#将所有的const和let分组-并隔行" class="headerlink" title="将所有的const和let分组,并隔行"></a>将所有的const和let分组,并隔行</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let i;</span><br><span class="line">const items=[];</span><br><span class="line">let d;</span><br><span class="line">const flag=true;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const flag=true;</span><br><span class="line">const items=[];</span><br><span class="line"></span><br><span class="line">let i;</span><br><span class="line">let d;</span><br></pre></td></tr></table></figure>

<h2 id="在需要的地方给变量-赋值，-但请把它们放在一个合理的位置。"><a href="#在需要的地方给变量-赋值，-但请把它们放在一个合理的位置。" class="headerlink" title="在需要的地方给变量 赋值， 但请把它们放在一个合理的位置。"></a>在需要的地方给变量 赋值， 但请把它们放在一个合理的位置。</h2><p>说明：let和const是作用域而不是函数作用域， 不用担心变量定义会被前移导致问题， 把变量的赋值和调用代码放在一起会使逻辑更加清晰， 可读性更好。</p>
<p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function(name)&#123;</span><br><span class="line">    const name=getName();</span><br><span class="line">    if(name)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setName(name);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function(name)&#123;</span><br><span class="line">    if(name)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const name=getName();</span><br><span class="line">    this.setName(name);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对象和引用"><a href="#对象和引用" class="headerlink" title="对象和引用"></a>对象和引用</h1><h2 id="创建有动态属性名的对象时，-尽量在一个地方定义对象的所有属性。"><a href="#创建有动态属性名的对象时，-尽量在一个地方定义对象的所有属性。" class="headerlink" title="创建有动态属性名的对象时， 尽量在一个地方定义对象的所有属性。"></a>创建有动态属性名的对象时， 尽量在一个地方定义对象的所有属性。</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const obj=&#123;</span><br><span class="line">    id:&#x27;aadadadaffaxvv&#x27;,</span><br><span class="line">    name:&#x27;zhangsan&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">obj[getKey(&#x27;enabled&#x27;)]=true;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj=&#123;</span><br><span class="line">    id:&#x27;aadadadaffaxvv&#x27;,</span><br><span class="line">    name:&#x27;zhangsan&#x27;,</span><br><span class="line">    obj[getKey(&#x27;enabled&#x27;)]:true,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用对象方法的简写。"><a href="#使用对象方法的简写。" class="headerlink" title="使用对象方法的简写。"></a>使用对象方法的简写。</h2><p>说明：ES6中， 对象字面量被增强了， 写法更加简洁与灵活， 同时在定义对象的时候， 能够做的事件更多了。</p>
<p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const atom = &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    addValue:function(value) &#123;</span><br><span class="line">        return atom.value + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const atom = &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    addValue(value) &#123;</span><br><span class="line">        return atom.value + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用对象属性的简写"><a href="#使用对象属性的简写" class="headerlink" title="使用对象属性的简写"></a>使用对象属性的简写</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  a: a,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">    a,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="使用扩展运算符-…-复制数组"><a href="#使用扩展运算符-…-复制数组" class="headerlink" title="使用扩展运算符 … 复制数组"></a>使用扩展运算符 … 复制数组</h2><p>扩展运算符可以减少赋值语句的使用， 或者减少通过下标访问数组或对象的方式， 使用代码更加简洁优雅， 可读性更佳。</p>
<p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const len = items.length;</span><br><span class="line">const itemsCopy = [];</span><br><span class="line"></span><br><span class="line">let i;</span><br><span class="line">for(i=0; i&lt;len; i++) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const itemsCopy = [...items];</span><br></pre></td></tr></table></figure>

<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="使用-来访问对象的属性，-只有属性是动态的时候使用-。"><a href="#使用-来访问对象的属性，-只有属性是动态的时候使用-。" class="headerlink" title="使用 . 来访问对象的属性， 只有属性是动态的时候使用 []。"></a>使用 . 来访问对象的属性， 只有属性是动态的时候使用 []。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const key=getKey();</span><br><span class="line">const props=obj[key];</span><br></pre></td></tr></table></figure>

<h1 id="逗号、分号"><a href="#逗号、分号" class="headerlink" title="逗号、分号"></a>逗号、分号</h1><h2 id="逗号写在行尾，-并且增加结尾的逗号。"><a href="#逗号写在行尾，-并且增加结尾的逗号。" class="headerlink" title="逗号写在行尾， 并且增加结尾的逗号。"></a>逗号写在行尾， 并且增加结尾的逗号。</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  firstName: &#x27;Dana&#x27;,</span><br><span class="line">  lastName: &#x27;Scally&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  firstName: &#x27;Dana&#x27;,</span><br><span class="line">  lastName: Scally&#x27;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="使用分号，-以分号作为语句的结束符。"><a href="#使用分号，-以分号作为语句的结束符。" class="headerlink" title="使用分号， 以分号作为语句的结束符。"></a>使用分号， 以分号作为语句的结束符。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(()=&gt;&#123;</span><br><span class="line">    const name=&#x27;a&#x27;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="使用函数声明代替函数表达式"><a href="#使用函数声明代替函数表达式" class="headerlink" title="使用函数声明代替函数表达式"></a>使用函数声明代替函数表达式</h2><p>说明：因为函数声明是可命名的， 所以他们在调用栈中更容易被识别。 此外， 函数声明会把整个函数提升， 而函数表达式只会把函数引用的变量名提升。 这条规则使得箭头函数可以取代函数表达式。</p>
<p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const function = foo()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不要使用arguments-可以选择rest语法-…-替代。"><a href="#不要使用arguments-可以选择rest语法-…-替代。" class="headerlink" title="不要使用arguments, 可以选择rest语法 … 替代。"></a>不要使用arguments, 可以选择rest语法 … 替代。</h2><p>说明：使用 … 能明确你要传入的参数， 另外， rest语法参数是一个真正的数组， 而arguments是一个类数组。</p>
<p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function concatenateAll() &#123;</span><br><span class="line">  const args = Array.prototype.slice.call(arguments);</span><br><span class="line">  return args.join(&#x27; &#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function concatenateAll(...args) &#123;</span><br><span class="line">  return args.join(&#x27; &#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="直接给函数的参数指定默认值，-不要使用一个变化的函数参数。"><a href="#直接给函数的参数指定默认值，-不要使用一个变化的函数参数。" class="headerlink" title="直接给函数的参数指定默认值， 不要使用一个变化的函数参数。"></a>直接给函数的参数指定默认值， 不要使用一个变化的函数参数。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function handle(opts=&#123;&#125;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="直接给函数参数赋值时，-需要避免副作用。"><a href="#直接给函数参数赋值时，-需要避免副作用。" class="headerlink" title="直接给函数参数赋值时， 需要避免副作用。"></a>直接给函数参数赋值时， 需要避免副作用。</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var b=1;</span><br><span class="line">function count(a=b++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">count();//1</span><br><span class="line">count();//2</span><br></pre></td></tr></table></figure>

<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><h2 id="使用大括号包裹所有的多行代码块。"><a href="#使用大括号包裹所有的多行代码块。" class="headerlink" title="使用大括号包裹所有的多行代码块。"></a>使用大括号包裹所有的多行代码块。</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(true) </span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">function ()&#123; return false &#125;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(true) return false;</span><br><span class="line">if(true) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ()&#123; </span><br><span class="line">    return false </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果通过if和else使用多行代码块， 把else放在if代码块关闭括号的同一行。</li>
</ol>
<p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(arg) &#123;</span><br><span class="line">  return arg;</span><br><span class="line">&#125; </span><br><span class="line">else &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(arg) &#123;</span><br><span class="line">  return arg;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="代码中总是使用ES6标准的模块（import-export-方式，-而不是使用非标准的模块加载器。"><a href="#代码中总是使用ES6标准的模块（import-export-方式，-而不是使用非标准的模块加载器。" class="headerlink" title="代码中总是使用ES6标准的模块（import/export)方式， 而不是使用非标准的模块加载器。"></a>代码中总是使用ES6标准的模块（import/export)方式， 而不是使用非标准的模块加载器。</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const AirbnbStyleGuide=require(&#x27;./AirbnbStyleGuide&#x27;);</span><br><span class="line">moudle.exports=AirbnbStyleGuide.es6;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import AirbnbStyleGuide from &#x27;/AirbnbStyleGuide&#x27;;</span><br><span class="line">export default AirbnbStyleGuide.es6;</span><br></pre></td></tr></table></figure>

<p><strong>更好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; es6 &#125; from &#x27;/AirbnbStyleGuide&#x27;;</span><br><span class="line">export default es6;</span><br></pre></td></tr></table></figure>

<h2 id="不要使用通配符-的import-。"><a href="#不要使用通配符-的import-。" class="headerlink" title="不要使用通配符 *的import 。"></a>不要使用通配符 *的import 。</h2><p>说明：这样可以确保被import的模块只有一个默认的export项。</p>
<p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as AirbnbStyleGuide from &#x27;/AirbnbStyleGuide&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import AirbnbStyleGuide from &#x27;/AirbnbStyleGuide&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="不要从import中直接export"><a href="#不要从import中直接export" class="headerlink" title="不要从import中直接export."></a>不要从import中直接export.</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123;es6 as defaults&#125; from &#x27;./ablier.js&#x27;; </span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123;es6&#125; from &#x27;./ablier.js&#x27;;</span><br><span class="line">export default es6;</span><br></pre></td></tr></table></figure>

<h2 id="如果你的文件只输出一个类，-那你的文件名必须和类名完全保持一致。"><a href="#如果你的文件只输出一个类，-那你的文件名必须和类名完全保持一致。" class="headerlink" title="如果你的文件只输出一个类， 那你的文件名必须和类名完全保持一致。"></a>如果你的文件只输出一个类， 那你的文件名必须和类名完全保持一致。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import CheckBox from &#x27;./CheckBox&#x27;;</span><br></pre></td></tr></table></figure>

<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><h2 id="别保存this的引用，-使用箭头函数或Function-bind。"><a href="#别保存this的引用，-使用箭头函数或Function-bind。" class="headerlink" title="别保存this的引用， 使用箭头函数或Function.bind。"></a>别保存this的引用， 使用箭头函数或Function.bind。</h2><p>说明：箭头函数提供了更简洁的语法， 并且箭头函数中的this对象指向是不变的， this绑定到定义时所在的对象。 通常情况下， 这是我们想要的， 有很好的代码可读性， 而保存this对象的使用方式， 会让开发人员搞混。</p>
<p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    const self=this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    const that=this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(that)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    return () =&gt;&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="当你必须使用函数表达式（或传递一个匿名函数）时，-使用箭头函数。"><a href="#当你必须使用函数表达式（或传递一个匿名函数）时，-使用箭头函数。" class="headerlink" title="当你必须使用函数表达式（或传递一个匿名函数）时， 使用箭头函数。"></a>当你必须使用函数表达式（或传递一个匿名函数）时， 使用箭头函数。</h2><p>说明：箭头函数创造了一个新的this执行环境。 通常情况下， 能满足你的需求， 而且这样的写更为简洁。 如果你有一个相当复杂的函数， 那么可以把逻辑部分转移到一个函数声明上。</p>
<p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].map(function(x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].map( (x) =&gt; &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="如果一个函数适用一行写出并且只有一个参数，-那就把花括号、圆括号和return都省略掉，-如果不是，-那就不要省略。"><a href="#如果一个函数适用一行写出并且只有一个参数，-那就把花括号、圆括号和return都省略掉，-如果不是，-那就不要省略。" class="headerlink" title="如果一个函数适用一行写出并且只有一个参数， 那就把花括号、圆括号和return都省略掉， 如果不是， 那就不要省略。"></a>如果一个函数适用一行写出并且只有一个参数， 那就把花括号、圆括号和return都省略掉， 如果不是， 那就不要省略。</h2><p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].map( x =&gt; x * x;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[1, 2, 3].reduce((total,n)=&gt;&#123;</span><br><span class="line">    return total+n;</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><h2 id="采用class关键字定义类"><a href="#采用class关键字定义类" class="headerlink" title="采用class关键字定义类"></a>采用class关键字定义类</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Queue(contents=[]&#123;</span><br><span class="line">    this._queue=[...contents];</span><br><span class="line">&#125;)</span><br><span class="line">Queue.prototype.pop=function()&#123;</span><br><span class="line">    const value=this._queue[0];</span><br><span class="line">    this.queue.splice(0,1);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Queue&#123;</span><br><span class="line">    constructor(contents=[])&#123;</span><br><span class="line">        this._queue=[...contents];</span><br><span class="line">    &#125;</span><br><span class="line">    pop()&#123;</span><br><span class="line">        const value=this._queue[0];</span><br><span class="line">        this.queue.splice(0,1);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="采用extends关键字实现继承。"><a href="#采用extends关键字实现继承。" class="headerlink" title="采用extends关键字实现继承。"></a>采用extends关键字实现继承。</h2><p>说明：因为extends是内建的继承方式， 并不会破坏instanceof原型检查。</p>
<p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const inherits=require(&#x27;inherits&#x27;);</span><br><span class="line">function peekableQueue(contents)&#123;</span><br><span class="line">    Queue.apply(this, contents)</span><br><span class="line">&#125;</span><br><span class="line">inherits(peekableQueue, Queue);</span><br><span class="line">peekableQueue.prototype.peek=function()&#123;</span><br><span class="line">    return this._queue[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class peekableQueue extends Queue&#123;</span><br><span class="line">   peek()&#123;</span><br><span class="line">       return this._queue[0];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><h2 id="使用解构存取和使用多属性对象。"><a href="#使用解构存取和使用多属性对象。" class="headerlink" title="使用解构存取和使用多属性对象。"></a>使用解构存取和使用多属性对象。</h2><p>说明：ES6允许按照一定的模式， 从数组和对象中提取值、对变量进行赋值， 这称之为解构， 解构赋值避免了临时变量或对象， 给JavaScript书写带来了很大的便利性， 同时也提高了代码的可读性。</p>
<p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getFullName (user) &#123;</span><br><span class="line">  const firstName = user.firstName;</span><br><span class="line">  const lastName = user.lastName;</span><br><span class="line">  return  `$&#123;firstName&#125; $&#123;lastName&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getFullName (&#123;firstName, lastName&#125;) &#123;</span><br><span class="line">  return `$&#123;firstName&#125; $&#123;lastName&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将数组成员赋值给变量时，-使用数组解析。"><a href="#将数组成员赋值给变量时，-使用数组解析。" class="headerlink" title="将数组成员赋值给变量时， 使用数组解析。"></a>将数组成员赋值给变量时， 使用数组解析。</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,2,3]</span><br><span class="line">const first=arr[0];</span><br><span class="line">const second=arr[1];</span><br></pre></td></tr></table></figure>
<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [first, second]=arr;</span><br></pre></td></tr></table></figure>


<h2 id="需要回传多个值时，-使用对象解构，-而不是数组解构。"><a href="#需要回传多个值时，-使用对象解构，-而不是数组解构。" class="headerlink" title="需要回传多个值时， 使用对象解构， 而不是数组解构。"></a>需要回传多个值时， 使用对象解构， 而不是数组解构。</h2><p>说明：对象解构在增加属性或改变排序时， 无需改变调用时的位置。</p>
<p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function input(inputType)&#123;</span><br><span class="line">    return [left, right, top, bottom]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用时候考虑回调函数顺序</span><br><span class="line">const [left, _, top]=input(inputType);</span><br></pre></td></tr></table></figure>
<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 调用时候只选择需要的数据</span><br><span class="line">const [left, top]=input(inputType);</span><br></pre></td></tr></table></figure>

<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="长度超过80的字符串应该使用字符串连接换行。"><a href="#长度超过80的字符串应该使用字符串连接换行。" class="headerlink" title="长度超过80的字符串应该使用字符串连接换行。"></a>长度超过80的字符串应该使用字符串连接换行。</h2><h2 id="构建字符串时，-使用字符串模板而不是字符串连接。"><a href="#构建字符串时，-使用字符串模板而不是字符串连接。" class="headerlink" title="构建字符串时， 使用字符串模板而不是字符串连接。"></a>构建字符串时， 使用字符串模板而不是字符串连接。</h2><p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sayHi(name) &#123;</span><br><span class="line">  return `How are you, $&#123;name&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组遍历采用for-of-对象遍历采用for-in。"><a href="#数组遍历采用for-of-对象遍历采用for-in。" class="headerlink" title="数组遍历采用for/of, 对象遍历采用for/in。"></a>数组遍历采用for/of, 对象遍历采用for/in。</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4];</span><br><span class="line">let sum = 0;</span><br><span class="line">for (let num in arr) &#123;</span><br><span class="line">  sum += num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4];</span><br><span class="line">let sum = 0;</span><br><span class="line">for (let num of arr) &#123;</span><br><span class="line">  sum += num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h1><h2 id="属性的存取函数不是必须的，-如果需要存储函数使用get方法和set方法。-如果属性是布尔值，-存取函数是isVal-或hasVal-。"><a href="#属性的存取函数不是必须的，-如果需要存储函数使用get方法和set方法。-如果属性是布尔值，-存取函数是isVal-或hasVal-。" class="headerlink" title="属性的存取函数不是必须的， 如果需要存储函数使用get方法和set方法。 如果属性是布尔值， 存取函数是isVal()或hasVal()。"></a>属性的存取函数不是必须的， 如果需要存储函数使用get方法和set方法。 如果属性是布尔值， 存取函数是isVal()或hasVal()。</h2><p><strong>不好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dragon.age();</span><br><span class="line">dragon.age(25);</span><br><span class="line">if (!dragon.age()) &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dragon.getAge();</span><br><span class="line">dragon.setAge(25);</span><br><span class="line">if (!dragon.getAge()) &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建get-和set-函数要保持一致。"><a href="#创建get-和set-函数要保持一致。" class="headerlink" title="创建get()和set()函数要保持一致。"></a>创建get()和set()函数要保持一致。</h2><p><strong>好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">  constructor (options = &#123;&#125;) &#123;</span><br><span class="line">      const lightsaber = options.lightsaber || &#x27;blue&#x27;;</span><br><span class="line">      this.set(&#x27;lightsaber&#x27;, lightsaber);</span><br><span class="line">  &#125;</span><br><span class="line">  set (key, val) &#123;</span><br><span class="line">    this[key] = val;</span><br><span class="line">  &#125;</span><br><span class="line">  get (key) &#123;</span><br><span class="line">    return this[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/05/14/JavaScript%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83(ES6)/" data-id="ckw8thujc0008e4d8gtcphoog" data-title="JavaScript语言编程规范(ES6)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-React-UI" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/13/React-UI/" class="article-date">
  <time class="dt-published" datetime="2019-05-13T14:10:13.000Z" itemprop="datePublished">2019-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/13/React-UI/">React-UI</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="使用开源的ant-design库开发项目指南"><a href="#使用开源的ant-design库开发项目指南" class="headerlink" title="使用开源的ant-design库开发项目指南"></a>使用开源的ant-design库开发项目指南</h1><h2 id="最流行的开源React-UI组件库"><a href="#最流行的开源React-UI组件库" class="headerlink" title="最流行的开源React UI组件库"></a>最流行的开源React UI组件库</h2><ul>
<li>material-ui(国外)<br> 官网: <a target="_blank" rel="noopener" href="http://www.material-ui.com/#/">http://www.material-ui.com/#/</a><br> github: <a target="_blank" rel="noopener" href="https://github.com/callemall/material-ui">https://github.com/callemall/material-ui</a></li>
<li>ant-design(国内蚂蚁金服)<br> 官网: <a target="_blank" rel="noopener" href="https://ant.design/">https://ant.design/</a><br> github: <a target="_blank" rel="noopener" href="https://github.com/ant-design/ant-design/">https://github.com/ant-design/ant-design/</a></li>
</ul>
<h2 id="ant-design使用入门"><a href="#ant-design使用入门" class="headerlink" title="ant-design使用入门"></a>ant-design使用入门</h2><h3 id="使用create-react-app搭建react开发环境"><a href="#使用create-react-app搭建react开发环境" class="headerlink" title="使用create-react-app搭建react开发环境"></a>使用create-react-app搭建react开发环境</h3><pre><code>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install create-react-app -g</span><br><span class="line">create-react-app antd-demo</span><br><span class="line">cd antd-demo</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="搭建antd的基本开发环境"><a href="#搭建antd的基本开发环境" class="headerlink" title="搭建antd的基本开发环境"></a>搭建antd的基本开发环境</h3><p>   下载<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install antd --save</span><br></pre></td></tr></table></figure><br>   src/App.js</p>
<pre><code>    import React, &#123; Component &#125; from &#39;react&#39;;
    import &#123; Button &#125; from &#39;antd&#39;;
    import &#39;./App.css&#39;;
    
    class App extends Component &#123;
      render() &#123;
        return (
          &lt;div className=&quot;App&quot;&gt;
            &lt;Button type=&quot;primary&quot;&gt;Button&lt;/Button&gt;
          &lt;/div&gt;
        );
      &#125;
    &#125;

    export default App;
</code></pre>
<p>   src/App.css</p>
<pre><code>    @import &#39;~antd/dist/antd.css&#39;;
    
    .App &#123;
      text-align: center;
    &#125;
</code></pre>
<h3 id="实现按需加载-css-js"><a href="#实现按需加载-css-js" class="headerlink" title="实现按需加载(css/js)"></a>实现按需加载(css/js)</h3><p>   使用 eject 命令将所有内建的配置暴露出来<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure><br>   下载babel-plugin-import(用于按需加载组件代码和样式的 babel 插件)<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-import --save-dev</span><br></pre></td></tr></table></figure><br>   修改配置: config/webpack.config.dev.js</p>
<pre><code>    // Process JS with Babel.
    &#123;
      test: /\.(js|jsx)$/,
      include: paths.appSrc,
      loader: &#39;babel&#39;,
      query: &#123;
      +   plugins: [
        +     [&#39;import&#39;, [&#123; libraryName: &quot;antd&quot;, style: &#39;css&#39; &#125;]],
        +   ],
      
        // This is a feature of `babel-loader` for webpack (not Babel itself).
        // It enables caching results in ./node_modules/.cache/babel-loader/
        // directory for faster rebuilds.
        cacheDirectory: true
      &#125;
    &#125;,
</code></pre>
<p>   去除引入全量样式的语句: src/App.css</p>
<pre><code>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &#x27;~antd/dist/antd.css&#x27;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="ant-design组件使用小样"><a href="#ant-design组件使用小样" class="headerlink" title="ant-design组件使用小样"></a>ant-design组件使用小样</h2><p><strong><a target="_blank" rel="noopener" href="https://github.com/heartwarming/antDesign">欢迎Fork</a></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/05/13/React-UI/" data-id="ckw8thujf000ce4d8874n559a" data-title="React-UI" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-React组件生命周期和钩子函数的介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/13/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2019-05-13T10:10:11.000Z" itemprop="datePublished">2019-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/13/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/">React组件生命周期和钩子函数的介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h1><h2 id="组件生命周期的执行次数是什么样子的？？？"><a href="#组件生命周期的执行次数是什么样子的？？？" class="headerlink" title="组件生命周期的执行次数是什么样子的？？？"></a>组件生命周期的执行次数是什么样子的？？？</h2><ul>
<li><p><strong>只执行一次</strong>： constructor、componentWillMount、componentDidMount</p>
</li>
<li><p><strong>执行多次</strong>：render 、子组件的componentWillReceiveProps、componentWillUpdate、componentDidUpdate</p>
</li>
<li><p><strong>有条件的执行</strong>：componentWillUnmount（页面离开，组件销毁时）</p>
</li>
<li><p><strong>不执行的</strong>：根组件（ReactDOM.render在DOM上的组件）的componentWillReceiveProps（因为压根没有父组件给传递props）</p>
</li>
</ul>
<h2 id="组件的生命周期执行顺序是什么样子的？？？"><a href="#组件的生命周期执行顺序是什么样子的？？？" class="headerlink" title="组件的生命周期执行顺序是什么样子的？？？"></a>组件的生命周期执行顺序是什么样子的？？？</h2><p><strong>生命周期代码探究</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class LifeCycle extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            person:&#123;</span><br><span class="line">                name:&#x27;fuhq&#x27;,</span><br><span class="line">                age: 18</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&#x27;constructor()&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 组件将要被挂载</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        //console.log(this);</span><br><span class="line">        console.log(&#x27;componentWillMount() 组件将要被挂载&#x27;)</span><br><span class="line">        // 发送ajax请求, 开启定时器</span><br><span class="line">        // 需要手动绑定改变this指向</span><br><span class="line">        // setTimeout(function()&#123;</span><br><span class="line">        //     this.setState(&#123;</span><br><span class="line">        //         person:&#123;</span><br><span class="line">        //             name:&#x27;yanggq&#x27;,</span><br><span class="line">        //             age: 19</span><br><span class="line">        //         &#125;</span><br><span class="line">        //     &#125;)</span><br><span class="line">        // &#125;.bind(this), 1000)</span><br><span class="line">        // 箭头函数更方便</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                person:&#123;</span><br><span class="line">                    name:&#x27;yanggq&#x27;,</span><br><span class="line">                    age: 19</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;</span><br><span class="line">    // 组件挂载完毕</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        console.log(&#x27;componentDidMount() 组件挂载完毕&#x27;)</span><br><span class="line">        // 官方推荐在这个钩子里面发送请求</span><br><span class="line">        // 发送ajax请求, 开启定时器</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">            // 卸载</span><br><span class="line">            ReactDom.unmoutComponentAtNode(document.getElementById(&#x27;example&#x27;))</span><br><span class="line">        &#125;, 4000)</span><br><span class="line"></span><br><span class="line">        this.intervalId = setInterval(function()&#123;</span><br><span class="line">            console.log(&#x27;setInterval()&#x27;)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">    // 组件将要更新</span><br><span class="line">    componentWillUpdate()&#123;</span><br><span class="line">        console.log(&#x27;componentWillUpdate() 组件将要更新&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 组件更新完毕</span><br><span class="line">    componentDidUpdate()&#123;</span><br><span class="line">        console.log(&#x27;componentDidUpdate() 组件更新完毕&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 组件将要被卸载</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        console.log(&#x27;componentWillUnmount() 组件将要被卸载&#x27;)</span><br><span class="line">        // 做一些收尾工作，关掉定时器</span><br><span class="line">        clearInterval(this.intervalId)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        console.log(&#x27;render()&#x27;)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;&#123;person.name&#125;:&#123;person.age&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;               </span><br><span class="line">&#125;</span><br><span class="line">React.render(&lt;LifeCycle /&gt;, document.getElementById(&#x27;example&#x27;));</span><br></pre></td></tr></table></figure>

<p><strong>控制台查看结果</strong></p>
<p><img src="/images/react_2.png"></p>
<p><strong>总结起来如下图</strong></p>
<p><img src="/images/react_3.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/05/13/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/" data-id="ckw8thujk000ie4d8am3d9fvq" data-title="React组件生命周期和钩子函数的介绍" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-React概览" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/13/React%E6%A6%82%E8%A7%88/" class="article-date">
  <time class="dt-published" datetime="2019-05-13T04:09:22.000Z" itemprop="datePublished">2019-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/13/React%E6%A6%82%E8%A7%88/">React概览</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="几个重要概念理解"><a href="#几个重要概念理解" class="headerlink" title="几个重要概念理解"></a>几个重要概念理解</h1><ul>
<li>模块与组件<br>  模块:<pre><code> 理解: 向外提供特定(局部)功能的js程序, 一般就是一个js文件
 为什么: js代码更多更复杂
 作用: 复用js, 简化js的编写, 提高js运行效率
</code></pre>
  组件: <pre><code> 理解: 用来实现特定功能效果的代码集合(html/css/js)
 为什么: 一个界面的功能更复杂
 作用: 复用编码, 简化项目编码, 提高运行效率
</code></pre>
</li>
<li>模块化与组件化<br>  模块化:<pre><code> 当应用的js都以模块来编写的, 这个应用就是一个模块化的应用
</code></pre>
  组件化:<pre><code> 当应用是以多组件的方式实现功能, 这上应用就是一个组件化的应用
</code></pre>
</li>
</ul>
<h1 id="React的基本认识"><a href="#React的基本认识" class="headerlink" title="React的基本认识"></a>React的基本认识</h1><ul>
<li>Facebook 发布用来动态构建用户界面的一个js库</li>
<li>React的特点<br>  Declarative(声明式编码)<br>  Component-Based(组件化编码)<br>  Learn Once, Write Anywhere(支持客户端与服务器渲染)<br>  高效<pre><code>  React高效的原因
      虚拟(virtual)DOM, 不总是直接操作DOM(批量更新, 减少更新的次数) 
      高效的DOM Diff算法, 最小化页面重绘(减小页面更新的区域)
</code></pre>
  单向数据流</li>
</ul>
<h1 id="使用React"><a href="#使用React" class="headerlink" title="使用React"></a>使用React</h1><ul>
<li>导入相关js库文件(react.js, react-dom.js, babel.min.js)</li>
</ul>
<p>编码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">var aa = 123</span><br><span class="line">ReactDOM.render(&lt;h1&gt;&#123;aa&#125;&lt;/h1&gt;, containerDOM);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><ul>
<li>全称: JavaScript XML</li>
<li>react定义的一种类似于XML的JS扩展语法: XML+JS,标签的class属性必须改为className属性</li>
<li>作用: 用来创建react虚拟DOM(元素)对象,js中直接可以套标签, 但标签要套js需要放在{}中</li>
</ul>
<p>把数据的数组转换为标签的数组: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var liArr = dataArr.map(function(item, index)&#123;</span><br><span class="line">    return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><ul>
<li>虚拟DOM是什么?<br>  一个虚拟DOM(元素)是一个一般的js对象, 准确的说是一个对象树(倒立的)<br>  虚拟DOM保存了真实DOM的层次关系和一些基本属性，与真实DOM一一对应<br>  如果只是更新虚拟DOM, 页面是不会重绘的</li>
<li>Virtual DOM 算法的基本步骤<br>  用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中<br>  当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异<br>  把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了</li>
<li>进一步理解<br>  Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。<br>  可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。<br>  CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。</li>
</ul>
<h1 id="Component-React是面向组件编程的-组件化编码开发"><a href="#Component-React是面向组件编程的-组件化编码开发" class="headerlink" title="Component : React是面向组件编程的(组件化编码开发)"></a>Component : React是面向组件编程的(组件化编码开发)</h1><h2 id="基本理解和使用"><a href="#基本理解和使用" class="headerlink" title="基本理解和使用"></a>基本理解和使用</h2><p><strong>自定义的标签: 组件类(函数)/标签</strong></p>
<p><strong>创建组件类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//方式1: 无状态函数(最简洁, 推荐使用)</span><br><span class="line">function MyComponent1() &#123;</span><br><span class="line">return &lt;h1&gt;自定义组件标题11111&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line">//方式2: ES6类语法(复杂组件, 推荐使用)</span><br><span class="line">class MyComponent3 extends React.Component &#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return &lt;h1&gt;自定义组件标题33333&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//方式3: ES5老语法(不推荐使用了)</span><br><span class="line">var MyComponent2 = React.createClass(&#123;</span><br><span class="line">render () &#123;</span><br><span class="line">    return &lt;h1&gt;自定义组件标题22222&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>渲染组件标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;MyComp /&gt;,  cotainerEle);</span><br></pre></td></tr></table></figure>

<h2 id="ReactDOM-render-渲染组件标签的基本流程"><a href="#ReactDOM-render-渲染组件标签的基本流程" class="headerlink" title="ReactDOM.render()渲染组件标签的基本流程"></a>ReactDOM.render()渲染组件标签的基本流程</h2><p>React内部会创建组件实例对象/调用组件函数, 得到虚拟DOM对象<br>将虚拟DOM并解析为真实DOM<br>插入到指定的页面元素内部</p>
<p><strong>props</strong></p>
<ul>
<li>所有组件标签的属性的集合对象</li>
<li>给标签指定属性, 保存外部数据(可能是一个function)</li>
<li>在组件内部读取属性: this.props.propertyName</li>
<li>作用: 从目标组件外部向组件内部传递数据</li>
</ul>
<p><strong>对props中的属性值进行类型限制和必要性限制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person.propTypes = &#123;</span><br><span class="line">name: React.PropTypes.string.isRequired,</span><br><span class="line">age: React.PropTypes.number.isRequired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="扩展属性-将对象的所有属性通过props传递"><a href="#扩展属性-将对象的所有属性通过props传递" class="headerlink" title="扩展属性: 将对象的所有属性通过props传递"></a>扩展属性: 将对象的所有属性通过props传递</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person &#123;...person&#125;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>组件的组合</strong></p>
<ul>
<li>组件标签中包含子组件标签</li>
<li>拆分组件: 拆分界面, 抽取组件</li>
<li>通过props传递数据</li>
</ul>
<p><strong>refs</strong></p>
<ul>
<li>组件内包含ref属性的标签元素的集合对象</li>
<li>给操作目标标签指定ref属性, 打一个标识</li>
<li>在组件内部获得标签对象: this.refs.refName(只是得到了标签元素对象)</li>
<li>作用: 操作组件内部的真实标签dom元素对象</li>
</ul>
<p><strong>事件处理</strong></p>
<ul>
<li><p>给标签添加属性: onXxx={this.eventHandler}</p>
</li>
<li><p>在组件中添加事件处理方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eventHandler(event) &#123;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使自定义方法中的this为组件对象</p>
</li>
<li><p>在constructor()中bind(this)</p>
</li>
<li><p>使用箭头函数定义方法(ES6模块化编码时才能使用)</p>
</li>
</ul>
<p><strong>state</strong></p>
<ul>
<li>组件被称为”状态机”, 页面的显示是根据组件的state属性的数据来显示</li>
<li>初始化指定:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">    stateName1 : stateValue1,</span><br><span class="line">    stateName2 : stateValue2</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读取显示:</strong></p>
<ul>
<li>this.state.stateName1</li>
<li>更新状态–&gt;更新界面 : </li>
<li>this.setState({stateName1 : newValue})</li>
</ul>
<p><strong>实现一个双向绑定的组件</strong></p>
<ul>
<li>React是单向数据流</li>
<li>需要通过onChange监听手动实现</li>
</ul>
<h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><ul>
<li>组件的三个生命周期状态:</li>
<li>Mount：插入真实 DOM</li>
<li>Update：被重新渲染</li>
<li>Unmount：被移出真实 DOM</li>
</ul>
<p><strong>生命周期流程:</strong></p>
<p>第一次初始化显示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor()</span><br><span class="line">componentWillMount() : 将要插入回调</span><br><span class="line">render() : 用于插入虚拟DOM回调</span><br><span class="line">componentDidMount() : 已经插入回调</span><br></pre></td></tr></table></figure>

<p>每次更新state</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(): 接收父组件新的属性</span><br><span class="line">componentWillUpdate() : 将要更新回调</span><br><span class="line">render() : 更新(重新渲染)</span><br><span class="line">componentDidUpdate() : 已经更新回调</span><br></pre></td></tr></table></figure>

<p>删除组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;example&#x27;)) : 移除组件</span><br><span class="line">componentWillUnmount() : 组件将要被移除回调</span><br></pre></td></tr></table></figure>

<p>常用的方法</p>
<pre><code>render(): 必须重写, 返回一个自定义的虚拟DOM
constructor(): 初始化状态, 绑定this(可以箭头函数代替)
componentDidMount() : 只执行一次, 已经在dom树中, 适合启动/设置一些监听
</code></pre>
<p><a href="ttps://heartwarming.github.io/2019/05/13/react生命周期/#more">更详细的介绍和实例请点击这里</a></p>
<h1 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h1><ul>
<li>React没有ajax模块</li>
<li>集成其它的js库(如axios/fetch/jQuery/), 发送ajax请求<br>  axios<pre><code>  封装XmlHttpRequest对象的ajax
  promise
  可以用在浏览器端和服务器
</code></pre>
  fetch<pre><code>  不再使用XmlHttpRequest对象提交ajax请求
  fetch就是用来提交ajax请求的函数, 只是新的浏览才内置了fetch
  为了兼容低版本的浏览器, 可以引入fetch.js
</code></pre>
  在哪个方法去发送ajax请求<pre><code>  只显示一次(请求一次): componentDidMount()
  显示多次(请求多次): componentWillReceiveProps()
</code></pre>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/05/13/React%E6%A6%82%E8%A7%88/" data-id="ckw8thujl000ke4d87op0duk8" data-title="React概览" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-vue2.x组件生命周期和钩子函数的介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/11/vue2.x%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2019-05-11T13:09:22.000Z" itemprop="datePublished">2019-05-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue2-x/">vue2.x</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/11/vue2.x%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/">vue2.x组件生命周期和钩子函数的介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h1><p>下图展示了实例的生命周期。随着你的不断学习和使用，它的参考价值会越来越高。</p>
<p><img src="/images/vue2.x_01.png"></p>
<h1 id="vue1-x和vue2-x对比图示"><a href="#vue1-x和vue2-x对比图示" class="headerlink" title="vue1.x和vue2.x对比图示"></a>vue1.x和vue2.x对比图示</h1><p><img src="/images/vue2.x_05.png"></p>
<h1 id="生命周期代码探究"><a href="#生命周期代码探究" class="headerlink" title="生命周期代码探究"></a>生命周期代码探究</h1><p><strong>直接粘到html文件中即可</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;meta name=&quot;&quot; content=&quot;&quot; charset=&quot;utf-8&quot;/&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">     &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">          message : &quot;xuxiao is boy&quot; </span><br><span class="line">      &#125;,</span><br><span class="line">       beforeCreate: function () &#123;</span><br><span class="line">                console.group(&#x27;beforeCreate 创建前状态===============》&#x27;);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el     : &quot; + this.$el); //undefined</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //undefined </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message)  </span><br><span class="line">        &#125;,</span><br><span class="line">        created: function () &#123;</span><br><span class="line">            console.group(&#x27;created 创建完毕状态===============》&#x27;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el); //undefined</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化 </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount: function () &#123;</span><br><span class="line">            console.group(&#x27;beforeMount 挂载前状态===============》&#x27;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + (this.$el)); //已被初始化</span><br><span class="line">            console.log(this.$el);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化  </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化  </span><br><span class="line">        &#125;,</span><br><span class="line">        mounted: function () &#123;</span><br><span class="line">            console.group(&#x27;mounted 挂载结束状态===============》&#x27;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el); //已被初始化</span><br><span class="line">            console.log(this.$el);    </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 </span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate: function () &#123;</span><br><span class="line">            console.group(&#x27;beforeUpdate 更新前状态===============》&#x27;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</span><br><span class="line">            console.log(this.$el);   </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); </span><br><span class="line">        &#125;,</span><br><span class="line">        updated: function () &#123;</span><br><span class="line">            console.group(&#x27;updated 更新完成状态===============》&#x27;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</span><br><span class="line">            console.log(this.$el); </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); </span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy: function () &#123;</span><br><span class="line">            console.group(&#x27;beforeDestroy 销毁前状态===============》&#x27;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</span><br><span class="line">            console.log(this.$el);    </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); </span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed: function () &#123;</span><br><span class="line">            console.group(&#x27;destroyed 销毁完成状态===============》&#x27;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</span><br><span class="line">            console.log(this.$el);  </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="create-和-mounted-相关"><a href="#create-和-mounted-相关" class="headerlink" title="create 和 mounted 相关"></a>create 和 mounted 相关</h2><p>咱们在chrome浏览器里打开，F12看console就能发现</p>
<ul>
<li><strong>beforecreated</strong>：el 和 data 并未初始化 </li>
<li><strong>created</strong>:完成了 data 数据的初始化，el没有</li>
<li><strong>beforeMount</strong>：完成了 el 和 data 初始化 </li>
<li><strong>mounted</strong> ：完成挂载</li>
</ul>
<p>另外在标红处，我们能发现el还是 ，这里就是应用的 Virtual DOM（虚拟Dom）技术，先把坑占住了。到后面mounted挂载的时候再把值渲染进去。</p>
<p><img src="/images/vue2.x_02.png"></p>
<h2 id="update-相关"><a href="#update-相关" class="headerlink" title="update 相关"></a>update 相关</h2><p>这里我们在 chrome console里执行以下命令<br><strong>app.message= ‘yes !! I do’;</strong><br>下面就能看到data里的值被修改后，将会触发update的操作。</p>
<p><img src="/images/vue2.x_03.png"></p>
<h2 id="destroy-相关"><a href="#destroy-相关" class="headerlink" title="destroy 相关"></a>destroy 相关</h2><p>有关于销毁，暂时还不是很清楚。我们在console里执行下命令app.$destroy();对 vue实例进行销毁。销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。</p>
<p><img src="/images/vue2.x_04.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><strong>beforecreate</strong> : 举个栗子：可以在这加个loading事件 </li>
<li><strong>created</strong> ：在这结束loading，还做一些初始化，实现函数自执行 </li>
<li><strong>mounted</strong> ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情</li>
<li><strong>beforeDestory</strong>： 你确认删除XX吗？ </li>
<li><strong>destoryed</strong> ：当前组件已被删除，清空相关内容</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/05/11/vue2.x%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/" data-id="ckw8thuk5001oe4d8a2yj8y0l" data-title="vue2.x组件生命周期和钩子函数的介绍" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-深，浅拷贝" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/10/%E6%B7%B1%EF%BC%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time class="dt-published" datetime="2019-05-10T13:06:45.000Z" itemprop="datePublished">2019-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/10/%E6%B7%B1%EF%BC%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">深，浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="深拷贝，浅拷贝的概念"><a href="#深拷贝，浅拷贝的概念" class="headerlink" title="深拷贝，浅拷贝的概念"></a>深拷贝，浅拷贝的概念</h1><p>简单点来说，就是假设通过B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，如果B没变，那就是深拷贝。</p>
<h2 id="为什么拷贝有深浅之分"><a href="#为什么拷贝有深浅之分" class="headerlink" title="为什么拷贝有深浅之分"></a>为什么拷贝有深浅之分</h2><p>我们来举个浅拷贝例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a=[0,1,2,3,4],</span><br><span class="line">    b=a;</span><br><span class="line">console.log(a===b);</span><br><span class="line">a[0]=1;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/images/c1.png"></p>
<p>b复制给了a，为啥修改数组a，数组b也跟着变了。</p>
<p>那么这里，就得引入基本数据类型与引用数据类型的概念了</p>
<p>基本数据类型有，number，string，boolean，null，undefined，symbol以及未来ES10新增的BigInt(任意精度整数)七类。</p>
<p>引用数据类型(Object类)有常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等。</p>
<p>而这两类数据存储分别是这样的：</p>
<p>a.基本类型–名值存储在栈内存中，例如let a=1;</p>
<p><img src="/images/c2.jpg"></p>
<p>当你b=a复制时，栈内存会新开辟一个内存，例如这样：</p>
<p><img src="/images/c3.jpg"></p>
<p>所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。</p>
<p>b.引用数据类型–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：</p>
<p><img src="/images/c4.jpg"></p>
<p>当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。</p>
<p><img src="/images/c5.jpg"></p>
<p>而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。</p>
<p> <img src="/images/c6.jpg"></p>
<p>那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，岂不就达到深拷贝的效果了</p>
<p><img src="/images/c7.jpg"></p>
<h1 id="实现深拷贝的方法"><a href="#实现深拷贝的方法" class="headerlink" title="实现深拷贝的方法"></a>实现深拷贝的方法</h1><h2 id="利用-递归-来实现深复制，对属性中所有引用类型的值，遍历到是基本类型的值为止"><a href="#利用-递归-来实现深复制，对属性中所有引用类型的值，遍历到是基本类型的值为止" class="headerlink" title="利用 递归 来实现深复制，对属性中所有引用类型的值，遍历到是基本类型的值为止"></a>利用 递归 来实现深复制，对属性中所有引用类型的值，遍历到是基本类型的值为止</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(source)&#123;    </span><br><span class="line">  if(!source &amp;&amp; typeof source !== &#x27;object&#x27;)&#123;      </span><br><span class="line">    throw new Error(&#x27;error arguments&#x27;, &#x27;shallowClone&#x27;);    </span><br><span class="line">  &#125;    </span><br><span class="line">  var targetObj = Array.isArray(source) ? [] : &#123;&#125;;    </span><br><span class="line">  for(var keys in source)&#123;       </span><br><span class="line">    if(source.hasOwnProperty(keys))&#123;          </span><br><span class="line">      if(source[keys] &amp;&amp; typeof source[keys] === &#x27;object&#x27;)&#123;  </span><br><span class="line">        targetObj[keys] = deepClone(source[keys]);    //递归      </span><br><span class="line">      &#125;else&#123;            </span><br><span class="line">        targetObj[keys] = source[keys];         </span><br><span class="line">      &#125;       </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line">  return targetObj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检测一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;name:&quot;jack&quot;,age:20&#125;;</span><br><span class="line">var b = deepClone(a);</span><br><span class="line">console.log(a === b);</span><br><span class="line">a.age = 30;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>
<p><img src="/images/c8.png"></p>
<h2 id="jQuery中的-extend-true-target-object1-objectN"><a href="#jQuery中的-extend-true-target-object1-objectN" class="headerlink" title="jQuery中的 extend(true, target, object1 [, objectN ])"></a>jQuery中的 extend(true, target, object1 [, objectN ])</h2><ul>
<li><p>$.extend( [deep ], target, object1 [, objectN ] )<br>  deep表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝</p>
<p>  target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。</p>
<p>  object1  objectN可选。 Object类型 第一个以及第N个被合并的对象。</p>
</li>
</ul>
<p>深拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name:&#x27;xixi&#x27;,age:20,company : &#123; name : &#x27;腾讯&#x27;, address : &#x27;深圳&#x27;&#125; &#125;;</span><br><span class="line">var obj_extend = $.extend(true,&#123;&#125;, obj); </span><br><span class="line">//extend方法，第一个参数为true，为深拷贝，为false，或者没有为浅拷贝。</span><br><span class="line">console.log(obj === obj_extend);</span><br><span class="line">obj.company.name = &quot;ali&quot;;</span><br><span class="line">obj.name = &quot;hei&quot;;</span><br><span class="line">console.log(obj);</span><br><span class="line">console.log(obj_extend);</span><br></pre></td></tr></table></figure>
<p><img src="/images/c9.png"></p>
<p>浅拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name:&quot;xixi&quot;,age:20&#125;;</span><br><span class="line">var obj_extend = $.extend(false,&#123;&#125;, obj); //extend方法，第一个参数为true，为深拷贝，为false，或者没有为浅拷贝。</span><br><span class="line">console.log(obj === obj_extend);</span><br><span class="line">obj.name = &quot;heihei&quot;;</span><br><span class="line">console.log(obj);</span><br><span class="line">console.log(obj_extend);</span><br></pre></td></tr></table></figure>
<p><img src="/images/c10.png"></p>
<h2 id="通过引入js的实用库-Lodash"><a href="#通过引入js的实用库-Lodash" class="headerlink" title="通过引入js的实用库 Lodash"></a>通过引入js的实用库 Lodash</h2><p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var objects = [&#123; &#x27;a&#x27;: 1 &#125;, &#123; &#x27;b&#x27;: 2 &#125;];</span><br><span class="line"> </span><br><span class="line">var deep = _.cloneDeep(objects);</span><br><span class="line">console.log(deep[0] === objects[0]);</span><br><span class="line">// =&gt; false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实现浅拷贝的方法"><a href="#实现浅拷贝的方法" class="headerlink" title="实现浅拷贝的方法"></a>实现浅拷贝的方法</h1><h2 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var syb = Symbol(&#x27;obj&#x27;);</span><br><span class="line">var person = &#123;</span><br><span class="line">   name :&#x27;tino&#x27;,</span><br><span class="line">   say: function()&#123;</span><br><span class="line">      console.log(&#x27;hi&#x27;);</span><br><span class="line">   &#125;,</span><br><span class="line">   ok: syb,</span><br><span class="line">   un: undefined</span><br><span class="line">&#125;</span><br><span class="line">var copy = JSON.parse(JSON.stringify(person))</span><br><span class="line">// copy</span><br><span class="line">// &#123;name: &quot;tino&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ps</strong>: 当值为undefined、function、symbol 会在转换过程中被忽略。。。所以，对象值有这三种的话用这种方法会导致属性丢失。</p>
<h2 id="Array-的-slice-和-concat-方法"><a href="#Array-的-slice-和-concat-方法" class="headerlink" title="Array 的 slice 和 concat 方法"></a>Array 的 slice 和 concat 方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = [[1,2,3],4,5];</span><br><span class="line">var b = a.slice();</span><br><span class="line">console.log(a === b);</span><br><span class="line">a[0][0] = 6;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>
<p><img src="/images/c11.png"></p>
<h2 id="Object-assgin"><a href="#Object-assgin" class="headerlink" title="Object.assgin()"></a>Object.assgin()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person1 = &#123;</span><br><span class="line">    name: &quot;xiaoming&quot;,</span><br><span class="line">    age: 18,</span><br><span class="line">    job: &quot;programmer&quot;</span><br><span class="line">&#125;</span><br><span class="line">var person2 = &#123;</span><br><span class="line">    age: 21,</span><br><span class="line">    stature: &quot;181cm&quot;</span><br><span class="line">&#125;</span><br><span class="line">var person = Object.assign(person1,person2);</span><br><span class="line"></span><br><span class="line">console.log(person)</span><br></pre></td></tr></table></figure>

<p><img src="/images/c11.png"></p>
<p><strong>其实总结一下就是：</strong></p>
<p>Array 的 slice 和 concat 和 Object.assign()，他们都会复制第一层的值，对于 第一层 的值都是 深拷贝，而到 第二层 如果key是引用类型的时候 就是 浅拷贝 。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果要复制的对象或者数组都是简单数据类型，放心大胆的使用。如果存在深层次的引用，选择方法的时候要慎重。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/05/10/%E6%B7%B1%EF%BC%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" data-id="ckw8thul0004te4d8fpikeoxo" data-title="深，浅拷贝" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-这一次，彻底弄懂JavaScript执行机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/09/%E8%BF%99%E4%B8%80%E6%AC%A1%EF%BC%8C%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2019-05-09T11:06:45.000Z" itemprop="datePublished">2019-05-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/09/%E8%BF%99%E4%B8%80%E6%AC%A1%EF%BC%8C%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/">这一次，彻底弄懂JavaScript执行机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="这一次，彻底弄懂-JavaScript-执行机制"><a href="#这一次，彻底弄懂-JavaScript-执行机制" class="headerlink" title="这一次，彻底弄懂 JavaScript 执行机制"></a>这一次，彻底弄懂 JavaScript 执行机制</h1><p>因为javascript是一门单线程语言，所以我们可以得出结论：</p>
<ul>
<li>javascript是按照语句出现的顺序执行的</li>
</ul>
<p>所以我们以为js都是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = &#x27;1&#x27;;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">const b = &#x27;2&#x27;;</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>
<p>然而实际上js是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&#x27;定时器开始啦&#x27;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;代码执行结束&#x27;);</span><br></pre></td></tr></table></figure>
<p>依照js是按照语句出现的顺序执行这个理念，我自信的写下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//&quot;定时器开始啦&quot;</span><br><span class="line">//&quot;代码执行结束&quot;</span><br></pre></td></tr></table></figure>
<p>去chrome上验证下，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//&quot;代码执行结束&quot;</span><br><span class="line">//&quot;定时器开始啦&quot;</span><br></pre></td></tr></table></figure>
<p>结果是这样的,瞬间懵了，说好的一行一行执行的呢？<br>这回我们真的要彻底弄明白javascript的执行机制了。</p>
<h2 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h2><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p>
<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<h2 id="javascript事件循环"><a href="#javascript事件循环" class="headerlink" title="javascript事件循环"></a>javascript事件循环</h2><p>既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p>
<ul>
<li>同步任务</li>
<li>异步任务</li>
</ul>
<p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：<br><img src="/images/el_01.png"><br>导图要表达的内容用文字来表述的话：</p>
<ul>
<li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li>
<li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li>
<li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li>
<li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li>
</ul>
<p>我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。<br>说了这么多文字，不如直接一段代码更直白：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;发送成功!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;代码执行结束&#x27;);</span><br></pre></td></tr></table></figure>
<p>上面是一段简易的ajax请求代码：</p>
<ul>
<li>ajax进入Event Table，注册回调函数success。</li>
<li>执行console.log(‘代码执行结束’)。</li>
<li>ajax事件完成，回调函数success进入Event Queue。</li>
<li>主线程从Event Queue读取回调函数success并执行。</li>
</ul>
<p>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。</p>
<h2 id="又爱又恨的setTimeout"><a href="#又爱又恨的setTimeout" class="headerlink" title="又爱又恨的setTimeout"></a>又爱又恨的setTimeout</h2><p>大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;延时3秒&#x27;);</span><br><span class="line">&#125;,3000)</span><br></pre></td></tr></table></figure>
<p>渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？<br>先看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;,3000)</span><br><span class="line">console.log(&#x27;执行console&#x27;);</span><br></pre></td></tr></table></figure>
<p>根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//执行console</span><br><span class="line">//task()</span><br></pre></td></tr></table></figure>
<p>去验证一下，结果正确！然后我们修改一下前面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,3000)</span><br><span class="line"></span><br><span class="line">sleep(10000000)</span><br></pre></td></tr></table></figure>
<p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？<br>这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的：</p>
<ul>
<li>task()进入Event Table并注册,计时开始。</li>
<li>执行sleep函数，很慢，非常慢，计时仍在继续。</li>
<li>3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。</li>
<li>sleep终于执行完了，task()终于从Event Queue进入了主线程执行。</li>
</ul>
<p>上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。<br>我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？<br>答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//代码1</span><br><span class="line">console.log(&#x27;先执行这里&#x27;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;执行啦&#x27;)</span><br><span class="line">&#125;,0);复制代码//代码2</span><br><span class="line">console.log(&#x27;先执行这里&#x27;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;执行啦&#x27;)</span><br><span class="line">&#125;,3000);</span><br></pre></td></tr></table></figure>
<p>代码1的输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//先执行这里</span><br><span class="line">//执行啦复制代码代码2的输出结果是：</span><br><span class="line">//先执行这里</span><br><span class="line">// ... 3s later</span><br><span class="line">// 执行啦</span><br></pre></td></tr></table></figure>
<p>关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。</p>
<h2 id="又恨又爱的setInterval"><a href="#又恨又爱的setInterval" class="headerlink" title="又恨又爱的setInterval"></a>又恨又爱的setInterval</h2><p>上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。<br>唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。</p>
<h2 id="Promise与process-nextTick-callback"><a href="#Promise与process-nextTick-callback" class="headerlink" title="Promise与process.nextTick(callback)"></a>Promise与process.nextTick(callback)</h2><p>传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。<br>Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。<br>我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p>
<ul>
<li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li>
<li>micro-task(微任务)：Promise，process.nextTick</li>
</ul>
<p>不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。<br>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;setTimeout&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#x27;promise&#x27;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#x27;then&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&#x27;console&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码作为宏任务，进入主线程。</li>
<li>先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</li>
<li>接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。</li>
<li>遇到console.log()，立即执行。</li>
<li>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。</li>
<li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。</li>
<li>结束。</li>
</ul>
<p>事件循环，宏任务，微任务的关系如图所示：</p>
<p><img src="/images/el_02.png"></p>
<p>我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;1&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;2&#x27;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#x27;3&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;4&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;5&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&#x27;6&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#x27;7&#x27;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#x27;8&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;9&#x27;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#x27;10&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;11&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;12&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第一轮事件循环流程分析如下：</p>
<ul>
<li>整体script作为第一个宏任务进入主线程，遇到console.log，输出1。</li>
<li>遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。</li>
<li>遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。</li>
<li>遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。</li>
<li>又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。</li>
</ul>
<p><strong>宏任务Event Queue</strong></p>
<ul>
<li>setTimeout1</li>
<li>process1</li>
</ul>
<p><strong>微任务Event Queue</strong></p>
<ul>
<li>setTimeout2</li>
<li>then1</li>
</ul>
<p>上面是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</p>
<p>我们发现了process1和then1两个微任务。</p>
<ul>
<li>执行process1,输出6。</li>
<li>执行then1，输出8。</li>
</ul>
<p>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始：</p>
<ul>
<li>首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。</li>
</ul>
<p><strong>宏任务Event Queue</strong></p>
<ul>
<li>setTimeout2</li>
</ul>
<p><strong>微任务Event Queue</strong></p>
<ul>
<li><p>process2</p>
</li>
<li><p>then2</p>
</li>
<li><p>第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。</p>
</li>
<li><p>输出3。</p>
</li>
<li><p>输出5。</p>
</li>
<li><p>第二轮事件循环结束，第二轮输出2，4，3，5。</p>
</li>
<li><p>第三轮事件循环开始，此时只剩setTimeout2了，执行。</p>
</li>
<li><p>直接输出9。</p>
</li>
<li><p>将process.nextTick()分发到微任务Event Queue中。记为process3。</p>
</li>
<li><p>直接执行new Promise，输出11。</p>
</li>
<li><p>将then分发到微任务Event Queue中，记为then3。</p>
</li>
</ul>
<p><strong>宏任务Event Queue</strong></p>
<ul>
<li>无</li>
</ul>
<p><strong>微任务Event Queue</strong></p>
<ul>
<li><p>process3</p>
</li>
<li><p>then3</p>
</li>
<li><p>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。</p>
</li>
<li><p>输出10。</p>
</li>
<li><p>输出12。</p>
</li>
<li><p>第三轮事件循环结束，第三轮输出9，11，10，12。</p>
</li>
</ul>
<p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>Tips: js执行和运行是有很大区别的</p>
<ul>
<li>javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。</li>
<li>运行大多指javascript解析引擎，是统一的。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/59e85eebf265da430d571f89">https://juejin.im/post/59e85eebf265da430d571f89</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/05/09/%E8%BF%99%E4%B8%80%E6%AC%A1%EF%BC%8C%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" data-id="ckw8thul3004ye4d80pn1628i" data-title="这一次，彻底弄懂JavaScript执行机制" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-使用Atomics避免SharedArrayBuffers中的竞争条件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/08/%E4%BD%BF%E7%94%A8Atomics%E9%81%BF%E5%85%8DSharedArrayBuffers%E4%B8%AD%E7%9A%84%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2019-05-08T14:55:45.000Z" itemprop="datePublished">2019-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/memory/">memory</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/08/%E4%BD%BF%E7%94%A8Atomics%E9%81%BF%E5%85%8DSharedArrayBuffers%E4%B8%AD%E7%9A%84%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/">使用Atomics避免SharedArrayBuffers中的竞争条件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="关于ECMAScript2017特性SharedArrayBuffer和atomics的背景知识："><a href="#关于ECMAScript2017特性SharedArrayBuffer和atomics的背景知识：" class="headerlink" title="关于ECMAScript2017特性SharedArrayBuffer和atomics的背景知识："></a>关于ECMAScript2017特性SharedArrayBuffer和atomics的背景知识：</h1><ul>
<li><a target="_blank" rel="noopener" href="https://heartwarming.github.io/heartwarming.github.io/2019/05/07/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%861/#more">内存管理的速成课程</a></li>
<li><a target="_blank" rel="noopener" href="https://heartwarming.github.io/heartwarming.github.io/2019/05/07/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%862/#more">ArrayBuffers和SharedArrayBuffers的介绍</a></li>
<li>[使用Atomics避免SharedArrayBuffers中的竞争条件]</li>
</ul>
<h2 id="使用Atomics避免SharedArrayBuffers中的竞争条件"><a href="#使用Atomics避免SharedArrayBuffers中的竞争条件" class="headerlink" title="使用Atomics避免SharedArrayBuffers中的竞争条件"></a>使用Atomics避免SharedArrayBuffers中的竞争条件</h2><p>在上一部分中，我谈到了使用SharedArrayBuffers如何导致竞争条件。这使得使用SharedArrayBuffers变得困难。我们不希望应用程序开发人员直接使用SharedArrayBuffers。</p>
<p>但是，具有其他语言多线程编程经验的库开发人员可以使用这些新的低级API来创建更高级别的工具。然后，应用程序开发人员可以直接使用这些工具而无需触及SharedArrayBuffers或Atomics。</p>
<p><img src="/images/memory_28.png"></p>
<p>即使您可能不应该直接使用SharedArrayBuffers和Atomics，我认为了解它们的工作原理仍然很有趣。因此，在本文中，我将解释并发可以带来什么样的竞争条件，以及Atomics如何帮助库避免它们。</p>
<p>但首先，什么是竞争条件？</p>
<p><img src="/images/memory_29.png"></p>
<p>比赛条件：您可能已经看过的一个例子<br>当你有一个在两个线程之间共享的变量时，就会发生一个非常简单的竞争条件示例。假设一个线程想要加载一个文件而另一个线程检查它是否存在。他们共享一个变量fileExists，进行沟通。</p>
<p>最初，fileExists设置为false。</p>
<p><img src="/images/memory_30.png"></p>
<p>只要线程2中的代码首先运行，就会加载该文件。</p>
<p><img src="/images/memory_31.png"></p>
<p>但是如果线程1中的代码首先运行，那么它将向用户记录一个错误，说该文件不存在。</p>
<p><img src="/images/memory_32.png"></p>
<p>但那不是问题。这不是文件不存在。真正的问题是竞争条件。</p>
<p>许多JavaScript开发人员都遇到过这种竞争条件，即使在单线程代码中也是如此。你不必了解多线程的任何信息，看看为什么这是一场比赛。</p>
<p>但是，有些种类的竞争条件在单线程代码中是不可能的，但是当您使用多个线程编程并且这些线程共享内存时可能会发生这种情况。</p>
<p><strong>不同类别的竞争条件以及Atomics如何提供帮助</strong><br>让我们探讨一下您可以在多线程代码中使用的各种竞争条件以及Atomics如何帮助防止它们。这并未涵盖所有可能的竞争条件，但应该让您知道为什么API提供它所执行的方法。</p>
<p>在我们开始之前，我想再说一遍：你不应该直接使用Atomics。编写多线程代码是一个众所周知的难题。相反，您应该使用可靠的库来处理多线程代码中的共享内存。</p>
<p><img src="/images/memory_33.png"></p>
<p>随着那个…</p>
<p>单次操作中的比赛条件<br>假设您有两个线程正在递增相同的变量。您可能认为无论哪个线程首先出现，最终结果都是相同的。</p>
<p><img src="/images/memory_34.png"></p>
<p>但即使在源代码中，递增变量看起来像一个操作，当您查看已编译的代码时，它不是单个操作。</p>
<p>在CPU级别，递增值需要三条指令。这是因为计算机具有长期记忆和短期记忆。（我在另一部分中更多地讨论了这一切是如何工作的）。</p>
<p><img src="/images/memory_35.png"></p>
<p>所有线程共享长期记忆。但短期内存 - 寄存器 - 不在线程之间共享。</p>
<p>每个线程都需要将内存中的值拉入其短期内存中。之后，它可以在短期记忆中对该值进行计算。然后它将该值从其短期记忆中写回到长期记忆中。</p>
<p><img src="/images/memory_36.png"></p>
<p>如果线程1中的所有操作首先发生，然后线程2中的所有操作都发生，我们将得到我们想要的结果。</p>
<p><img src="/images/memory_37.png"></p>
<p>但是如果它们在时间上交错，则线程2拉入其寄存器的值与内存中的值不同步。这意味着线程2不考虑线程1的计算。相反，它只是破坏了线程1用自己的值写入内存的值。</p>
<p><img src="/images/memory_38.png"></p>
<p>原子操作所做的一件事是将人类认为是单个操作的这些操作，但计算机视为多个操作，并使计算机将它们视为单个操作。</p>
<p>这就是他们被称为原子操作的原因。这是因为他们采取的操作通常会有多个指令 - 指令可以暂停和恢复 - 并且它使得它们看起来都是瞬间发生的，就像它是一条指令一样。它就像一个不可分割的原子。</p>
<p><img src="/images/memory_39.png"></p>
<p>使用原子操作，递增的代码看起来会有所不同。</p>
<p><img src="/images/memory_40.png"></p>
<p>现在我们正在使用Atomics.add，增加变量所涉及的不同步骤不会在线程之间混淆。相反，一个线程将完成其原子操作并阻止另一个线程启动。然后另一个将开始自己的原子操作。</p>
<p><img src="/images/memory_41.png"></p>
<p>有助于避免这种竞争的原子方法是：</p>
<ul>
<li>Atomics.add</li>
<li>Atomics.sub</li>
<li>Atomics.and</li>
<li>Atomics.or</li>
<li>Atomics.xor</li>
<li>Atomics.exchange</li>
</ul>
<p>您会注意到此列表相当有限。它甚至不包括除法和乘法之类的东西。但是，库开发人员可以为其他事情创建类似原子的操作。</p>
<p>为此，开发人员将使用Atomics.compareExchange。这样，您可以从SharedArrayBuffer获取一个值，对其执行操作，并且如果您第一次检查后没有其他线程更新它，则只将其写回SharedArrayBuffer。如果另一个线程已更新它，那么您可以获取该新值并再试一次。</p>
<p><strong>多个操作的竞争条件</strong><br>因此，这些原子操作有助于在“单一操作”期间避免竞争条件。但有时您希望更改对象上的多个值（使用多个操作）并确保没有其他人同时对该对象进行更改。基本上，这意味着在对象的每次更改过程中，该对象都处于锁定状态，并且其他线程无法访问。</p>
<p>Atomics对象不提供任何直接处理此工具的工具。但它确实提供了图书馆作者可以用来处理这个问题的工具。库作者可以创建的是锁。</p>
<p><img src="/images/memory_42.png"></p>
<p>如果代码想要使用锁定数据，则必须获取数据锁。然后它可以使用锁来锁定其他线程。只有在锁定处于活动状态时才能访问或更新数据。</p>
<p>要构建锁，库作者将使用Atomics.wait和Atomics.wake，以及其他诸如Atomics.compareExchange和Atomics.store。如果您想了解这些是如何工作的，请看一下这个基本的锁实现。</p>
<p>在这种情况下，线程2将获取数据的锁定并将值设置locked为true。这意味着在线程2解锁之前，线程1无法访问数据。</p>
<p><img src="/images/memory_43.png"></p>
<p>如果线程1需要访问数据，它将尝试获取锁。但由于锁已经在使用，它不能。然后线程将等待 - 因此它将被阻止 - 直到锁可用。</p>
<p><img src="/images/memory_44.png"></p>
<p>一旦线程2完成，它将调用解锁。锁将通知一个或多个等待线程它现在可用。</p>
<p><img src="/images/memory_45.png"></p>
<p>然后该线程可以挖出锁并锁定数据供自己使用。</p>
<p><img src="/images/memory_46.png"></p>
<p>锁库将在Atomics对象上使用许多不同的方法，但对于此用例最重要的方法是：</p>
<ul>
<li>Atomics.wait</li>
<li>Atomics.wake</li>
</ul>
<p><strong>指令重新排序引起的竞争条件</strong><br>Atomics会解决第三个同步问题。这个可能令人惊讶。</p>
<p>您可能没有意识到这一点，但是您编写的代码很可能没有按照您期望的顺序运行。编译器和CPU都重新排序代码以使其运行得更快。</p>
<p>例如，假设您已经编写了一些代码来计算总计。您想在计算完成时设置标志。</p>
<p><img src="/images/memory_47.png"></p>
<p>为了编译它，我们需要决定每个变量使用哪个寄存器。然后我们可以将源代码翻译成机器的指令。</p>
<p><img src="/images/memory_48.png"></p>
<p>到目前为止，一切都如预期。</p>
<p>如果您不了解计算机在芯片级别的工作方式（以及它们用于执行代码工作的管道如何），那么我们的代码中的第2行需要等待一段时间才能执行，这一点并不明显。</p>
<p>大多数计算机将执行指令的过程分解为多个步骤。这可以确保CPU的所有不同部分始终处于忙碌状态，因此可以充分利用CPU。</p>
<p>以下是指令执行步骤的一个示例：</p>
<ul>
<li>从内存中获取下一条指令</li>
<li>弄清楚指令告诉我们做什么（也就是解码指令），并从寄存器中获取值</li>
<li>执行指令</li>
<li>将结果写回寄存器</li>
</ul>
<p><img src="/images/memory_49.png"></p>
<p><img src="/images/memory_50.png"></p>
<p><img src="/images/memory_51.png"></p>
<p><img src="/images/memory_52.png"></p>
<p>这就是一条指令通过管道的方式。理想情况下，我们希望在它之后直接跟随第二条指令。一旦进入第2阶段，我们想要获取下一条指令。</p>
<p>问题是指令＃1和指令＃2之间存在依赖关系。</p>
<p><img src="/images/memory_53.png"></p>
<p>我们可以暂停CPU直到指令＃1 subTotal在寄存器中更新。但这会减慢事情的速度。</p>
<p>为了提高效率，许多编译器和CPU将做的是重新排序代码。他们将寻找不使用其他指令subTotal或total与这两条线之间搬完英寸</p>
<p><img src="/images/memory_54.png"></p>
<p>这样可以保持稳定的指令流在管道中移动。</p>
<p>因为第3行不依赖于第1行或第2行中的任何值，所以编译器或CPU认为像这样重新排序是安全的。当你在一个线程中运行时，无论如何，在整个函数完成之前，其他任何代码都不会看到这些值。</p>
<p>但是当你在另一个处理器上同时运行另一个线程时，情况并非如此。另一个线程不必等到函数完成才能看到这些更改。几乎只要它们被写回内存就可以看到它们。所以它可以告诉它isDone在总计之前设定。</p>
<p>如果你使用isDone的total是已经计算好并且准备在另一个线程中使用的标志，那么这种重新排序会产生竞争条件。</p>
<p>Atomics试图解决其中的一些错误。当您使用Atomic写入时，就像在代码的两个部分之间放置一个栅栏。</p>
<p>原子操作不会相对于彼此重新排序，并且其他操作不会在它们周围移动。特别是，通常用于强制排序的两个操作是：</p>
<ul>
<li>Atomics.load</li>
<li>Atomics.store</li>
</ul>
<p>Atomics.store函数源代码中的所有变量更新都保证在将Atomics.store其值写回内存之前完成。即使非原子指令相对于彼此重新排序，它们也不会移动到Atomics.store源代码中的下面的调用之下。</p>
<p>并且Atomics.load在函数之后的所有变量加载都保证在Atomics.load获取其值之后完成。同样，即使非原子指令被重新排序，它们也不会被移动Atomics.load到源代码中位于它们之上的指令之上。</p>
<p><img src="/images/memory_55.png"></p>
<p>注意：我在这里展示的while循环称为自旋锁，效率非常低。如果它在主线程上，它可以使您的应用程序停止。你几乎肯定不想在实际代码中使用它。</p>
<p>再一次，这些方法并不真正意味着直接在应用程序代码中使用。相反，库会使用它们来创建锁。</p>
<p><strong>结论</strong><br>编程共享内存的多个线程很难。有许多不同种类的竞争条件等着你绊倒你。</p>
<p><img src="/images/memory_56.png"></p>
<p>这就是您不希望直接在应用程序代码中使用SharedArrayBuffers和Atomics的原因。相反，您应该依赖于具有多线程经验并且花时间研究内存模型的开发人员经过验证的库。</p>
<p>SharedArrayBuffer和Atomics仍处于早期阶段。那些图书馆尚未创建。但是这些新的API提供了构建的基础。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/05/08/%E4%BD%BF%E7%94%A8Atomics%E9%81%BF%E5%85%8DSharedArrayBuffers%E4%B8%AD%E7%9A%84%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/" data-id="ckw8thukd0022e4d8hfix5ot1" data-title="使用Atomics避免SharedArrayBuffers中的竞争条件" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ArrayBuffers和SharedArrayBuffers的介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/08/ArrayBuffers%E5%92%8CSharedArrayBuffers%E7%9A%84%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2019-05-08T13:35:10.000Z" itemprop="datePublished">2019-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/memory/">memory</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/08/ArrayBuffers%E5%92%8CSharedArrayBuffers%E7%9A%84%E4%BB%8B%E7%BB%8D/">ArrayBuffers和SharedArrayBuffers的介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="关于ECMAScript2017特性SharedArrayBuffer和atomics的背景知识："><a href="#关于ECMAScript2017特性SharedArrayBuffer和atomics的背景知识：" class="headerlink" title="关于ECMAScript2017特性SharedArrayBuffer和atomics的背景知识："></a>关于ECMAScript2017特性SharedArrayBuffer和atomics的背景知识：</h1><ul>
<li><a target="_blank" rel="noopener" href="https://heartwarming.github.io/heartwarming.github.io/2019/05/07/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%861/#more">内存管理的速成课程</a></li>
<li>ArrayBuffers和SharedArrayBuffers的介绍</li>
<li><a target="_blank" rel="noopener" href="https://heartwarming.github.io/heartwarming.github.io/2019/05/07/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%863/#more">使用Atomics避免SharedArrayBuffers中的竞争条件</a></li>
</ul>
<h2 id="ArrayBuffers和SharedArrayBuffers的介绍"><a href="#ArrayBuffers和SharedArrayBuffers的介绍" class="headerlink" title="ArrayBuffers和SharedArrayBuffers的介绍"></a>ArrayBuffers和SharedArrayBuffers的介绍</h2><p>在上一部分中，我解释了像JavaScript这样的内存管理语言如何处理内存。我还解释了手动内存管理如何在C语言中工作。</p>
<p>当我们谈论ArrayBuffers和SharedArrayBuffers时，为什么这很重要？</p>
<p>这是因为ArrayBuffers为您提供了一种手动处理某些数据的方法，即使您使用的是具有自动内存管理功能的JavaScript。</p>
<p>为什么这是你想做的事情？</p>
<p>正如我们在上一部分中所讨论的那样，在自动内存管理方面存在一种权衡。对开发人员来说更容易，但它增加了一些开销。在某些情况下，这种开销会导致性能问题。</p>
<p><img src="/images/memory_13.png"></p>
<p>例如，当您在JS中创建变量时，引擎必须猜测这是什么类型的变量以及它应该如何在内存中表示。因为它在猜测，JS引擎通常会保留比变量真正需要的空间更多的空间。根据变量，内存插槽可能比它需要的大2-8倍，这可能导致大量浪费的内存。</p>
<p>此外，某些创建和使用JS对象的模式可能会使收集垃圾变得更加困难。如果您正在进行手动内存管理，则可以选择适合您正在使用的用例的分配和取消分配策略。</p>
<p>大多数时候，这不值得麻烦。大多数用例对性能不敏感，您需要担心手动内存管理。对于常见用例，手动内存管理可能会更慢。</p>
<p>但是，当您需要在低级别工作以尽可能快地使代码时，ArrayBuffers和SharedArrayBuffers会为您提供一个选项。</p>
<p><img src="/images/memory_14.png"></p>
<p><strong>那么ArrayBuffer是如何工作的呢？</strong><br>它基本上就像使用任何其他JavaScript数组一样。除了使用ArrayBuffer时，您不能将任何JavaScript类型放入其中，如对象或字符串。您可以添加的唯一内容是字节（您可以使用数字表示）。</p>
<p><img src="/images/memory_15.png"></p>
<p>我应该在这里说清楚的一点是，你实际上并没有将这个字节直接添加到ArrayBuffer中。就其本身而言，这个ArrayBuffer不知道该字节应该有多大，或者不应该将不同类型的数字转换为字节。</p>
<p>ArrayBuffer本身只是一堆零和一行。ArrayBuffer不知道该数组中第一个元素和第二个元素之间的除法位置。</p>
<p><img src="/images/memory_16.png"></p>
<p>为了提供上下文，实际上将其分解为框，我们需要将其包装在所谓的视图中。可以使用类型化数组添加这些数据视图，并且可以使用许多不同类型的类型化数组。</p>
<p>例如，您可以使用Int8类型的数组，将其分解为8位字节。</p>
<p><img src="/images/memory_17.png"></p>
<p>或者你可以有一个无符号的Int16数组，它可以将它分解为16位的数据，并且还可以像处理无符号整数一样处理它。</p>
<p><img src="/images/memory_18.png"></p>
<p>您甚至可以在同一个基本缓冲区上拥有多个视图。不同的视图将为您提供相同操作的不同结果。</p>
<p>例如，如果我们从这个ArrayBuffer的Int8视图中获取元素0和1，它将在Uint16视图中给出与元素0不同的值，即使它们包含完全相同的位。</p>
<p><img src="/images/memory_19.png"></p>
<p>通过这种方式，ArrayBuffer基本上就像原始内存一样。它模仿了像C这样的语言的直接内存访问。</p>
<p>您可能想知道为什么我们不让程序员直接访问内存而不是添加这个抽象层。直接访问内存会打开一些安全漏洞。我将在以后的部分中详细解释这个问题。</p>
<p><strong>那么，什么是SharedArrayBuffer？</strong><br>为了解释SharedArrayBuffers，我需要解释一下并行运行代码和JavaScript。</p>
<p>您可以并行运行代码以使代码运行得更快，或使代码更快地响应用户事件。为此，您需要拆分工作。</p>
<p>在一个典型的应用程序中，工作由一个人 - 主线程完成。我之前已经谈过这个……主线程就像一个全栈开发者。它负责JavaScript，DOM和布局。</p>
<p>您可以采取任何措施从主线程的工作负载中删除工作。在某些情况下，ArrayBuffers可以减少主线程必须完成的工作量。</p>
<p><img src="/images/memory_20.png"></p>
<p>但有时候减少主线程的工作量是不够的。有时你需要引进增援……你需要分开工作。</p>
<p>在大多数编程语言中，通常使用称为线程的方法来分解工作。这基本上就像有多个人在一个项目上工作。如果您的任务彼此非常独立，则可以将它们分配给不同的线程。然后，这两个线程可以同时处理它们各自的任务。</p>
<p>在JavaScript中，您执行此操作的方式是使用称为Web worker的东西。这些Web工作者与您在其他语言中使用的线程略有不同。默认情况下，它们不共享内存。</p>
<p><img src="/images/memory_21.png"></p>
<p>这意味着如果要与其他线程共享某些数据，则必须将其复制。这是通过函数postMessage完成的。</p>
<p>postMessage接受您放入其中的任何对象，对其进行序列化，将其发送给其他Web工作者，然后将其反序列化并放入内存中。</p>
<p><img src="/images/memory_22.png"></p>
<p>这是一个非常缓慢的过程。</p>
<p>对于某些类型的数据，如ArrayBuffers，您可以执行所谓的传输内存。这意味着移动特定的内存块，以便其他Web工作者可以访问它。</p>
<p>但是第一个Web工作者再也无法访问它了。</p>
<p><img src="/images/memory_23.png"></p>
<p>这适用于某些用例，但对于许多需要具有此类高性能并行性的用例，您真正需要的是拥有共享内存。</p>
<p>这就是SharedArrayBuffers为您提供的。</p>
<p><img src="/images/memory_24.png"></p>
<p>使用SharedArrayBuffer，两个Web工作者（两个线程）都可以写入数据并从同一块内存中读取数据。</p>
<p>这意味着他们没有使用postMessage的通信开销和延迟。两个Web工作人员都可以立即访问数据。</p>
<p>但是，同时从两个线程立即访问存在一些危险。它可以导致所谓的竞争条件。</p>
<p><img src="/images/memory_25.png"></p>
<p>我将在下一部分中详细解释这些内容。</p>
<p><strong>SharedArrayBuffers的当前状态是什么？</strong><br>SharedArrayBuffers将很快出现在所有主流浏览器中。</p>
<p><img src="/images/memory_26.png"></p>
<p>它们已经在Safari中运行（在Safari 10.1中）。Firefox和Chrome都将在7月/ 8月的版本中发布它们。Edge计划在秋季Windows更新中发布它们。</p>
<p>即使它们在所有主流浏览器中都可用，我们也不希望应用程序开发人员直接使用它们。事实上，我们建议不要这样做。您应该使用可用的最高级别的抽象。</p>
<p>我们所期望的是JavaScript库开发人员将创建库，使您可以更轻松，更安全地使用SharedArrayBuffers。</p>
<p>此外，一旦SharedArrayBuffers内置到平台中，WebAssembly就可以使用它们来实现对线程的支持。一旦到位，您就可以使用像Rust这样的语言的并发抽象，它将无畏并发作为其主要目标之一。</p>
<p>在接下来的部分中，我们将看看工具（原子能），这些库作者会使用来建立这些抽象，同时避免竞争条件。<br><img src="/images/memory_27.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/05/08/ArrayBuffers%E5%92%8CSharedArrayBuffers%E7%9A%84%E4%BB%8B%E7%BB%8D/" data-id="ckw8thuj30001e4d8cc1oa0x5" data-title="ArrayBuffers和SharedArrayBuffers的介绍" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ngnix/">Ngnix</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ajax/">ajax</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cache/">cache</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css2-1/">css2.1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/funny/">funny</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/memory/">memory</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project/">project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storage/">storage</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/utils/">utils</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue2-x/">vue2.x</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%88%86%E4%BA%AB/" style="font-size: 10px;">分享</a> <a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 10px;">导航</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/07/02/%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%85%BC%E5%AE%B9/">软件的兼容</a>
          </li>
        
          <li>
            <a href="/2019/09/09/webpack%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/">webpack异步加载组件原理.md</a>
          </li>
        
          <li>
            <a href="/2019/09/09/%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD/">组件的按需加载</a>
          </li>
        
          <li>
            <a href="/2019/09/06/%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型链</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>