<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/21/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-11-21T05:24:38.332Z" itemprop="datePublished">2021-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/21/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/21/hello-world/" data-id="ckw8sqgwr0000kwd87icofwuq" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-软件的兼容" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/02/%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%85%BC%E5%AE%B9/" class="article-date">
  <time class="dt-published" datetime="2020-07-02T11:20:45.000Z" itemprop="datePublished">2020-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/other/">other</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/02/%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%85%BC%E5%AE%B9/">软件的兼容</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>向上兼容等同于作向前兼容，向下兼容等同于向后兼容。主流使用的是向前兼容和向后兼容。向后兼容中“后”指“落后”，站在新版本的立场讨论过去版本的兼性问题。向前兼容中“前”指“前进”，表示未来的事情，站在旧版本的立场讨论未来版本的兼容性问题。</p>
<h1 id="微软网站对“向后兼容”和“向前兼容”的理解："><a href="#微软网站对“向后兼容”和“向前兼容”的理解：" class="headerlink" title="微软网站对“向后兼容”和“向前兼容”的理解："></a>微软网站对“向后兼容”和“向前兼容”的理解：</h1><h2 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h2><p>2007 Microsoft Office 系统向后兼容下列早期版本：Microsoft Office 2000、Microsoft Office XP 和 Microsoft Office 2003。这些版本的用户可以轻松地采用新的格式，并继续从现有文件中获得最大的益处。特别是他们还可以继续使用旧的 .doc、.xls 和 .ppt 二进制格式，这些格式与 2007 文件格式完全兼容。</p>
<h2 id="向前兼容"><a href="#向前兼容" class="headerlink" title="向前兼容"></a>向前兼容</h2><p>应用程序的早期版本能够打开较新版本中的文件并忽略早期版本中未实现的功能。例如，Word 2003 向前兼容 Word 2007，因为它能够成功地使用转换器打开 Word 2007 文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/02/%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%85%BC%E5%AE%B9/" data-id="ckw8thul1004we4d8br957y32" data-title="软件的兼容" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-webpack异步加载组件原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/09/webpack%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2019-09-09T08:09:22.000Z" itemprop="datePublished">2019-09-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue2-x/">vue2.x</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/09/webpack%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/">webpack异步加载组件原理.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="按需加载的好处"><a href="#按需加载的好处" class="headerlink" title="按需加载的好处"></a>按需加载的好处</h1><p>单页spa应用大行其道，但是我们往往开发过程中需要配置很多的路由引入。当打包构建的时候，javascript包会变得非常大，影响加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。结合Vue的异步组件和webpackde code splitting feature,轻松实现路由组件的懒加载。</p>
<p>就像图片的懒加载一样，如果客户根本就没有看到那些图片，而我们却在打开页面的时候全部给加载完了，这样会大大的增加请求的时间，降低用户的体验程度。懒加载在很多的网站都有用到，比如淘宝、京东等等这样的购物网站，上面的图片链接等等都很多，如果你把滚轴迅速的往下拉的时候，你可能会看到图片加载的情况。</p>
<p>单页应用也是一样，用户可能没有通过点击跳转到其他的的页面，而是只在主页面进行了停留，那么我们就没有必要把其他页面的资源全部加载过来。如果用户点进去再加载。这样就可以大大提高请求时间，提高用户的体验程度。</p>
<p>webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。</p>
<p>不进行页面按需加载引入方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import  home   from &#x27;../../common/home.vue&#x27;</span><br></pre></td></tr></table></figure>

<p>进行页面按需加载的引入方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const  home = r =&gt; require.ensure( [], () =&gt; r (require(&#x27;../../common/home.vue&#x27;))</span><br></pre></td></tr></table></figure>

<p>webpack ensure相信大家都听过。有人称它为异步加载，也有人说做代码切割，那这个家伙到底是用来干嘛的？其实说白了，它就是把js模块给独立导出一个.js文件的，然后使用这个模块的时候，webpack会构造script dom元素，由浏览器发起异步请求这个js文件。</p>
<h1 id="需求场景分析"><a href="#需求场景分析" class="headerlink" title="需求场景分析:"></a>需求场景分析:</h1><p>比如应用的首页里面有个按钮，点击后可以打开某个地图。打开地图的话就要利用百度地图的js,于是我们不得不在首页中把百度地图的js一起打包进去首页,一个百度地图的js文件是非常大的，假设为1m，于是就造成了我们首页打包的js非常大，用户打开首页的时间就比较长了。有没有什么好的解决方法呢？</p>
<p>当然还是有的！我们细想，百度地图是用户点击了才弹出来的，也就是说，这个功能是可选的。那么解决方案就来了，能不能在用户点击的时候，我在去下载百度地图的js.当然可以。那如何实现用户点击的时候再去下载百度地图的js呢？于是，我们可以写一<br>个按钮的监听器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mapBtn.click(function() &#123;</span><br><span class="line">  //获取 文档head对象</span><br><span class="line">  var head = document.getElementsByTagName(&#x27;head&#x27;)[0];</span><br><span class="line">  //构建 &lt;script&gt;</span><br><span class="line">  var script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">  //设置src属性</span><br><span class="line">  script.async = true;</span><br><span class="line">  script.src = &quot;http://map.baidu.com/.js&quot;</span><br><span class="line">  //加入到head对象中</span><br><span class="line">  head.appendChild(script);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的几行代码对大家来说都不难。可以在点击的时候，才加载百度地图，等百度地图加载完成后，在利用百度地图的对象去执行我们的操作。ok，讲到这里webpack.ensure的原理也就讲了一大半了。它就是把一些js模块给独立出一个个js文件，然后需要用到的时候，在创建一个script对象，加入到document.head对象中即可，浏览器会自动帮我们发起请求，去请求这个js文件，在写个回调，去定义得到这个js文件后，需要做什么业务逻辑操作。</p>
<p>ok,那么我们就利用webpack的api去帮我们完成这样一件事情。点击后才进行异步加载百度地图js，上面的click加载js时我们自己写的，webpack可以轻松帮我们搞定这样的事情，而不用我们手写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapBtn.click(function() &#123;</span><br><span class="line">  require.ensure([], function() &#123;</span><br><span class="line">    var baidumap = require(&#x27;./baidumap.js&#x27;) //baidumap.js放在我们当前目录下</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>搞定！当然还是分析一下。require.ensure这个函数是一个代码分离的分割线，表示 回调里面的require是我们想要进行分割出去的，即require(’./baidumap.js’)，把baidumap.js分割出去，形成一个webpack打包的单独js文件。当然ensure里面也是可以写一些同步的require的，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var sync = require(&#x27;syncdemo.js&#x27;)   //下面ensure里面也用到</span><br><span class="line"> </span><br><span class="line">mapBtn.click(function() &#123;</span><br><span class="line">  require.ensure([], function() &#123;</span><br><span class="line">    var baidumap = require(&#x27;./baidumap.js&#x27;) //baidumap.js放在我们当前目录下</span><br><span class="line">    var sync = require(&#x27;syncdemo.js&#x27;)  //这个不会独立出去，因为它已经加载到模块缓存中了</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也就是说，ensure会把没有使用过的require资源进行独立分成成一个js文件. require.ensure的第一个参数是什么意思呢？[], 其实就是 当前这个 require.ensure所依赖的其他 异步加载的模块。你想啊？如果A 和 B都是异步加载的，B中需要A，那么B下载之前，是不是先要下载A啊？，所以ensure的第一个参数[]是它依赖的异步模块，但是这里需要注意的是，webpack会把参数里面的依赖异步模块和当前的需要分离出去的异步模块给一起打包成同一个js文件，这里可能会出现一个重复打包的问题， 假设A 和 B都是异步的， ensure A 中依赖B，ensure B中 依赖A，那么会生成两个文件，都包含A和B模块。 如果想加载A require.ensure([‘A.js’],function) 即可</p>
<p>说完了上面的原理。下面就实践一下</p>
<p><img src="/images/vue2.x_06.png"></p>
<p>entry.js 依赖三个 js。</p>
<p>Abtn-work.js 是封装了 abtn按钮点击后，才执行的业务逻辑<br>Bbtn-work.js 是封装了 bbtn按钮点击后，才执行的业务逻辑<br>util.js 是封装了 entry.js需要利用的工具箱<br>针对上面的需求，优化方案</p>
<p>假设 Abtn-work.js Bbtn-work.js util.js都是非常大的文件因为 Abtn-work.js Bbtn-work.js 都不是entry.js必须有的，即可能发生的操作，那么我们把他们利用异步加载，当发生的时候再去加载就行了</p>
<p>util.js是entry.js立即马上依赖的工具箱。但是它又非常的大，所以将其配置打包成一个公共模块，利用浏览器的并发加载，加快下载速度。ok,构思完成，开始实现</p>
<p>index.html</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;index&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;aBtn&quot;&gt;Abtn&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;bBtn&quot;&gt;Bbtn&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">定义了两个buttom</span><br><span class="line"></span><br><span class="line">然后看看 entry.js</span><br><span class="line"></span><br><span class="line">var util_sync = require(&#x27;./util-sync.js&#x27;)</span><br><span class="line"> </span><br><span class="line">alert(util_sync.data)</span><br><span class="line"> </span><br><span class="line">document.getElementById(&quot;aBtn&quot;).onclick = function() &#123;</span><br><span class="line"> </span><br><span class="line">  require.ensure([], function() &#123;</span><br><span class="line">    var awork = require(&#x27;./workA-async.js&#x27;)</span><br><span class="line">    alert(awork.data)</span><br><span class="line">    //异步里面再导入同步模块--实际是使用同步中的模块</span><br><span class="line">    var util1 = require(&#x27;./util-sync.js&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">document.getElementById(&quot;bBtn&quot;).onclick = function() &#123;</span><br><span class="line"> </span><br><span class="line">  require.ensure([], function() &#123;</span><br><span class="line">    var bwork = require(&#x27;./workB-async.js&#x27;)</span><br><span class="line">    alert(bwork.data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，workA-async.js， workB-async.js 都是点击后才ensure进来的。什么时候加载完成呢？就是 require.ensure() 第二个函数参数，即回调函数，它表示当下载js完成后，发生的因为逻辑</p>
<p>webpack打包后，形成</p>
<p><img src="/images/vue2.x_07.png"></p>
<p>其实， 1.1… 2.2…就是我们ensure导出来的js文件</p>
<p>我们看看代码是如何加载的执行的，点击打包插入js后的html</p>
<p><img src="/images/vue2.x_08.png"></p>
<p>发现浏览器下载并加载了 1.1…js</p>
<p>点击 bbtn</p>
<p><img src="/images/vue2.x_09.png"></p>
<p>发现浏览器下载并加载了 2.2…js</p>
<p>其实项目优化，还有通过减少向服务器请求的次数来减少等待的时间。比如，一个页面的数据包括图片、文字等用户都已经加载完了，然后用户通过点击跳转到了另外一个界面。然后从另外一个界面通过返回又回到了原先的界面。如果没有设置的话，那么原先界面的信息就要重新向服务器请求得到。而通过vue提供的keep-alive可以是页面的已经请求的数据得以保存，减少请求的次数，提高用户的体验程度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/09/webpack%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/" data-id="ckw8thuk9001ye4d8brrx82lf" data-title="webpack异步加载组件原理.md" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-组件的按需加载" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/09/%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD/" class="article-date">
  <time class="dt-published" datetime="2019-09-09T05:09:22.000Z" itemprop="datePublished">2019-09-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue2-x/">vue2.x</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/09/%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD/">组件的按需加载</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="vue项目实现按需加载的3种方式："><a href="#vue项目实现按需加载的3种方式：" class="headerlink" title="vue项目实现按需加载的3种方式："></a>vue项目实现按需加载的3种方式：</h1><ul>
<li>vue异步组件、</li>
<li>es提案的import()</li>
<li>webpack的require.ensure()</li>
</ul>
<h2 id="vue异步组件技术"><a href="#vue异步组件技术" class="headerlink" title="vue异步组件技术"></a>vue异步组件技术</h2><p>在使用vue-router配置路由时，使用vue的异步组件技术，可以实现按需加载。</p>
<p>但是，这种情况下一个组件生成一个js文件。</p>
<p>举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#x27;/promisedemo&#x27;,</span><br><span class="line">    name: &#x27;PromiseDemo&#x27;,</span><br><span class="line">    component: resolve =&gt; require([&#x27;../components/PromiseDemo&#x27;], resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="es提案的import"><a href="#es提案的import" class="headerlink" title="es提案的import()"></a>es提案的import()</h2><p>vue-router配置路由，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 下面2行代码，没有指定webpackChunkName，每个组件打包成一个js文件。</span><br><span class="line">const ImportFuncDemo1 = () =&gt; import(&#x27;../components/ImportFuncDemo1&#x27;)</span><br><span class="line">const ImportFuncDemo2 = () =&gt; import(&#x27;../components/ImportFuncDemo2&#x27;)</span><br><span class="line">// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。</span><br><span class="line">// const ImportFuncDemo = () =&gt; import(/* webpackChunkName: &#x27;ImportFuncDemo&#x27; */ &#x27;../components/ImportFuncDemo&#x27;)</span><br><span class="line">// const ImportFuncDemo2 = () =&gt; import(/* webpackChunkName: &#x27;ImportFuncDemo&#x27; */ &#x27;../components/ImportFuncDemo2&#x27;)</span><br><span class="line">export default new Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#x27;/importfuncdemo1&#x27;,</span><br><span class="line">            name: &#x27;ImportFuncDemo1&#x27;,</span><br><span class="line">            component: ImportFuncDemo1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#x27;/importfuncdemo2&#x27;,</span><br><span class="line">            name: &#x27;ImportFuncDemo2&#x27;,</span><br><span class="line">            component: ImportFuncDemo2</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="webpack提供的require-ensure"><a href="#webpack提供的require-ensure" class="headerlink" title="webpack提供的require.ensure()"></a>webpack提供的require.ensure()</h2><p>vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。</p>
<p>这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p>
<p>举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#x27;/promisedemo&#x27;,</span><br><span class="line">    name: &#x27;PromiseDemo&#x27;,</span><br><span class="line">    component: resolve =&gt; require.ensure([], () =&gt; resolve(require(&#x27;../components/PromiseDemo&#x27;)), &#x27;demo&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    path: &#x27;/hello&#x27;,</span><br><span class="line">    name: &#x27;Hello&#x27;,</span><br><span class="line">    // component: Hello</span><br><span class="line">    component: resolve =&gt; require.ensure([], () =&gt; resolve(require(&#x27;../components/Hello&#x27;)), &#x27;demo&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://heartwarming.github.io/heartwarming.github.io/2019/09/09/webpack%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/#more">webpack提供的require.ensure()异步加载的原理请看</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/09/%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD/" data-id="ckw8thul1004ue4d85uovefhj" data-title="组件的按需加载" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-原型链" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/06/%E5%8E%9F%E5%9E%8B%E9%93%BE/" class="article-date">
  <time class="dt-published" datetime="2019-09-06T08:16:45.000Z" itemprop="datePublished">2019-09-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/06/%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型链</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><ul>
<li>访问一个对象的属性时<ul>
<li>先在自身属性中查找，找到返回</li>
<li>如果没找到，继续沿着__proto__这条链向上查找，找到返回</li>
<li>如果最终没找到，返回undefined</li>
</ul>
</li>
<li>别名(隐式原型链)</li>
<li>作用：查找对象的属性(方法)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="构造函数-原型-实例对象"><a href="#构造函数-原型-实例对象" class="headerlink" title="构造函数/原型/实例对象"></a>构造函数/原型/实例对象</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/06/%E5%8E%9F%E5%9E%8B%E9%93%BE/" data-id="ckw8thukk002le4d8bq0s2z0m" data-title="原型链" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-显示原型与隐式原型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/06/%E6%98%BE%E7%A4%BA%E5%8E%9F%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2019-09-06T05:36:45.000Z" itemprop="datePublished">2019-09-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/06/%E6%98%BE%E7%A4%BA%E5%8E%9F%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B/">显示原型与隐式原型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>每个函数function在定义时都有一个属性prototype，称为显示原型。</li>
<li>每个实例对象创建时都有一个属性__proto__，称为隐式原型。</li>
<li>实例对象的隐式原型的值为对应构造函数的显示原型的值。</li>
</ul>
<p><strong>注意：</strong> 显示原型可以操作，隐式原型不能直接操作(ES6之前)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fun()&#123; // 内部语句 this.prototype = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fun = new Fun();</span><br><span class="line"></span><br><span class="line">console.log(Fun.prototype === fun.__proto__)  // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/06/%E6%98%BE%E7%A4%BA%E5%8E%9F%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B/" data-id="ckw8thukn002we4d82urh6znh" data-title="显示原型与隐式原型" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-prototype" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/06/prototype/" class="article-date">
  <time class="dt-published" datetime="2019-09-06T01:36:45.000Z" itemprop="datePublished">2019-09-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/06/prototype/">prototype</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="函数的prototype属性"><a href="#函数的prototype属性" class="headerlink" title="函数的prototype属性"></a>函数的prototype属性</h1><ul>
<li>每个函数都会有一个prototype属性，它默认指向一个Object={}空对象(即原型对象)</li>
<li>原型对象中有一个constructor属性，指向函数对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(fun.prototype);</span><br><span class="line">console.log(fun.prototype.constructor===fun); //true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出如下:</p>
<p><img src="/images/js_4.png"></p>
<h1 id="给原型对象添加属性-多数是方法"><a href="#给原型对象添加属性-多数是方法" class="headerlink" title="给原型对象添加属性(多数是方法)"></a>给原型对象添加属性(多数是方法)</h1><ul>
<li>构造函数的所有实例对象会自动拥有原型中的属性(多数是方法)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fun()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Fun.prototype.test = function ()&#123;</span><br><span class="line">    console.log(&#x27;test&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">var fun = new Fun();</span><br><span class="line">fun.test();             // test</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/06/prototype/" data-id="ckw8thuk2001ie4d8ekz27qjj" data-title="prototype" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-js基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/05/js%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2019-09-05T06:36:45.000Z" itemprop="datePublished">2019-09-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/05/js%E5%9F%BA%E7%A1%80/">js基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要是基础知识的深化，内容包括：<br>数据类型：判断方法、变量类型与数据类型、数据在堆栈空间中的储存细节<br>对象：对象是多个（种）数据的容器，两种访问内部数据的方法<br>函数：函数也是对象，也有属性和方法。IIEF、this指向问题</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基本（值）类型"><a href="#基本（值）类型" class="headerlink" title="基本（值）类型"></a>基本（值）类型</h2><p><img src="/images/js_1.png"></p>
<h2 id="对象（引用）类型"><a href="#对象（引用）类型" class="headerlink" title="对象（引用）类型"></a>对象（引用）类型</h2><p><img src="/images/js_2.png"></p>
<h1 id="数据、内存、变量"><a href="#数据、内存、变量" class="headerlink" title="数据、内存、变量"></a>数据、内存、变量</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>存储在内存中的信息，以二进制（0101101）的形式保存，可传递</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存条通电后产生的临时储存空间</p>
<ul>
<li>一块“内存”（一个字节）包含两部分信息<ul>
<li>内部储存的数据</li>
<li>该内存的地址值</li>
</ul>
</li>
<li>内存空间分类<ul>
<li>栈空间    全局变量/局部变量，表示对象名的变量，空间较小    </li>
<li>堆空间  储存对象，空间较大</li>
</ul>
</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量名，用来查找到对应的内存<br>变量值，内存中保存的数据</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据类型和变量类型不同，变量类型分为两种，一种保存值，一种保存地址</p>
<ul>
<li>基本类型（保存值）：保存基本类型的数据</li>
<li>引用类型（保存地址)：保存对象类型的数据的地址</li>
</ul>
<h1 id="对象的理解与使用"><a href="#对象的理解与使用" class="headerlink" title="对象的理解与使用"></a>对象的理解与使用</h1><h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h2><p>保存多个数据（多种数据类型）的容器。这些数据每一个都有键名（key）和值（value）</p>
<h2 id="对象的属性和方法"><a href="#对象的属性和方法" class="headerlink" title="对象的属性和方法"></a>对象的属性和方法</h2><p>对象的属性和方法都是对象内部的数据，根据数据类型的不同划分为两类。<br>属性：保存的数据类型是基本类型、普通对象Object、数组类型Array<br>方法：保存的数据类型是函数类型Function</p>
<h2 id="访问对象内部的数据"><a href="#访问对象内部的数据" class="headerlink" title="访问对象内部的数据"></a>访问对象内部的数据</h2><p>方法一（有时候不管用）：.数据键名<br>方法二(通用方法）：[‘数据键名’]，数据键名有特殊字符/或者是一个变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">var key = &#x27;Server&#x27;</span><br><span class="line">obj[&#x27;content-type&#x27;] = &#x27;JSON&#x27;</span><br><span class="line">obj[key] = &#x27;nginx&#x27;</span><br><span class="line">console.log(obj)</span><br></pre></td></tr></table></figure>

<h1 id="函数的理解与使用"><a href="#函数的理解与使用" class="headerlink" title="函数的理解与使用"></a>函数的理解与使用</h1><h2 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h2><p>用来实现特定功能的, n条语句的封装体，可以执行</p>
<h2 id="函数是对象，也有属性和方法"><a href="#函数是对象，也有属性和方法" class="headerlink" title="函数是对象，也有属性和方法"></a>函数是对象，也有属性和方法</h2><p>属性：test.prototype<br>方法：**test.call/apply(obj)**。这个方法可以让test临时成为obj的方法</p>
<h2 id="IIEF"><a href="#IIEF" class="headerlink" title="IIEF"></a>IIEF</h2><p>全名：Immediately-Invoked Function Expression立即调用函数表达，<br>别名：匿名函数自调用<br>作用：隐藏实现，不污染外部（全局）命名空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function (i) &#123;</span><br><span class="line">var a = 4</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&#x27;fn &#x27;, i+a)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line">&#125;)(3)</span><br></pre></td></tr></table></figure>

<h2 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h2><p>this是什么：<br>一个内置的引用变量，代表调用函数的当前对象，既然如此，那么this具体指的是谁，只有当函数执行才知道，谁调用，this就是谁。<br>如何确定this的值？这里假设已定义了函数test</p>
<p><img src="/images/js_3.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/05/js%E5%9F%BA%E7%A1%80/" data-id="ckw8thujy001be4d8cunu9rtr" data-title="js基础" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-package-lock" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/04/package-lock/" class="article-date">
  <time class="dt-published" datetime="2019-09-04T06:26:45.000Z" itemprop="datePublished">2019-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/project/">project</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/04/package-lock/">package-lock.json需要写进.gitignore吗?</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>npm 是有锁版本机制的，而package-lock.json文件是当 node_modules/ 或 package.json 发生变化时自动生成的文件，它的主要功能是 确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。</p>
<h1 id="package-lock-json需要写进-gitignore吗"><a href="#package-lock-json需要写进-gitignore吗" class="headerlink" title="package-lock.json需要写进.gitignore吗?"></a>package-lock.json需要写进.gitignore吗?</h1><p>package-lock.json 不应写进 .gitignore。这点无论你是否使用 lock 都是一样的。</p>
<p>具体来说：如果你使用 lock 机制，则应该将 package-lock.json 提交到 repo 中。比如 Vue 采取了该策略。如果你不使用 lock 机制，则应该加入 .npmrc 文件，内容为 package-lock=false ，并提交到 repo 中。比如 ESLint 采取了该策略。</p>
<p>例外是，如果你使用 yarn 并且不打算使用 npm，则可以把 package-lock.json 列入 .gitignore（比如 Babel）；反之如果你使用 npm 并且不打算使用 yarn，则可以把 yarn.lock 列入 .gitignore （比如 TypeScript）。比如 jQuery 为什么把 package-lock.json 写入 .gitignore 。简单说就是 optional 依赖包会导致不同平台上的 package-lock.json 发生变更。jQuery 的人认为这有问题，所以暂时性 ignore 了它。先不管是不是有更好的方式或者其他 workaround，最新的 npm 5.6.0 其实已经解决了这个问题。</p>
<p>有一些不使用 lock 机制的库，已经使用了 .npmrc ，但也把 package-lock.json 列入了 .gitignore，这是没有必要的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/04/package-lock/" data-id="ckw8thuk0001ee4d8exlg6hfx" data-title="package-lock.json需要写进.gitignore吗?" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-git基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/03/git%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2019-09-03T08:20:45.000Z" itemprop="datePublished">2019-09-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Git/">Git</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/03/git%E5%9F%BA%E7%A1%80/">git基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h1><p>安装完成后，用以下命令将用户信息全局初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>**注意: **git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h1 id="创建版本库并初始化"><a href="#创建版本库并初始化" class="headerlink" title="创建版本库并初始化"></a>创建版本库并初始化</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br></pre></td></tr></table></figure>

<p>以上三行命令分别为创建目录、进入目录以及查看当前目录位置。<br><strong>注意：</strong> 路径中最好不要有中文</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure>
<p>初始化，会在此目录下建立一个隐藏的.git文件夹，用来跟踪管理版本库。<br>言归正传，现在我们编写一个readme.txt文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>
<p>添加文件，可连续多次添加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure>
<p>提交文件，把添加的所有文件一次提交，-m后面是提交信息，最好写有意义的描述。然后可以看到修改信息。</p>
<h1 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h1><h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><p>先将原文件的第7行加入单词distributed ，然后在第8行后面添加一行Very Good!<br>显示当前库的状态，会提示变动过哪些文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>

<h2 id="版本对比"><a href="#版本对比" class="headerlink" title="版本对比"></a>版本对比</h2><p>查看和上一版本的具体变动内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff test.txt</span><br></pre></td></tr></table></figure>

<p>显示内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/test.txt b/test.txt</span><br><span class="line">index 629d9c8..3d98a7f 100644</span><br><span class="line">--- a/test.txt</span><br><span class="line">+++ b/test.txt</span><br><span class="line">@@ -4,8 +4,9 @@ test line3.</span><br><span class="line"> test line4.</span><br><span class="line"> test line5.</span><br><span class="line"> test line6.</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br><span class="line">+Very Good!</span><br><span class="line"> test line7.</span><br><span class="line"> test line8.</span><br><span class="line"> test line9.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>详解：</strong></p>
<ul>
<li>diff –git a/test.txt b/test.txt ——对比两个文件，其中a改动前，b是改动后，以git的diff格式显示；</li>
<li>index 629d9c8..3d98a7f 100644 ——两个版本的git哈希值，index区域（add之后）的 629d9c8 对象和工作区域的 3d98a7f 对象， 100表示普通文件，644表示权限控制；</li>
<li>— a/test.txt +++ b/test.txt ——减号表示变动前，加号表示变动后；</li>
<li>@@ -4,8 +4,9 @@ test line3. ——@@表示文件变动描述合并显示的开始和结束，一般在变动前后多显示3行，其中-+表示变动前后，逗号前是起始行位置，逗号后为从起始行往后几行。合起来变动前后都是从第4行开始，变动前文件往后数8行对应变动后文件往后数9行。</li>
<li>变动内容 ——+表示增加了这一行，-表示删除了这一行，没符号表示此行没有变动。</li>
</ul>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure>
<p>用来查看最近三次提交的记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br></pre></td></tr></table></figure>
<p>合并每条记录到一行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<p>向前回退版本，其中HEAD后面跟几个^就是往回退几个版本，如果回退100个版本，可以写成 HEAD~100 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 07e0</span><br></pre></td></tr></table></figure>
<p>向后恢复版本，首先要查找到对应版本的哈希id前4位，如果提交窗口找不到，可以使用以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>
<p>这个命令记录了每一次版本相关的操作。git回退的速度非常快，因为在git内部有一个指向当前版本的HEAD指针，回退到某个版本，实际上是git把指针移动指向某个版本</p>
<h1 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h1><ul>
<li>工作区（Working Directory）：.git所在的目录下，除了.git之外的其他文件都是在工作区内</li>
<li>版本库（Repository）：.git目录内所存的记录，有暂存区和Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</li>
<li>stage（或者叫index）的暂存区：用add命令放进来文件的位置</li>
</ul>
<p><img src="/images/git_1.png"></p>
<ul>
<li>如果文件在工作区被编辑，对应的status状态就是 Changes not staged for commit </li>
<li>如果工作区新增文件，则对应的status状态就是 Untracked files </li>
<li>如果文件被add后，对应的status状态就是 Changes to be committed </li>
<li>多次add后的文件都放在暂存区，最后一次性全部提交。提交后的status状态就是 nothing to commit, working tree clean这时候工作区就是干净的，暂存区就没有任何内容了。</li>
</ul>
<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>如果一个文件，修改一次后，add，再修改一次后直接commit，然后status则显示还有一次修改没有被提交，因为提交只对暂存区生效。所以要么每改动一次后都add，最后一次性提交；要么add一次就提交一次。<br>比较工作区与暂存区<br>　　git diff 不加参数即默认比较工作区与暂存区<br>比较暂存区与最新本地版本库（本地库中最近一次commit的内容）<br>　　git diff –cached  [<path>…]<br>比较工作区与最新本地版本库<br>　　git diff HEAD [<path>…]  如果HEAD指向的是master分支，那么HEAD还可以换成master</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>如果在工作区修改了文件后的status，会提示，下一步可以add到暂存区，或者从暂存区恢复修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br></pre></td></tr></table></figure>

<p>想要撤销，就用第3行的命令<br>$ git checkout – test.txt</p>
<p>如果已经add到暂存区了，这时想要撤销操作，这时可以从status中的提示——从HEAD中恢复修改。<br>$ git reset HEAD</p>
<p>但这时候暂存区的修改撤销了，工作区还是修改后的内容，此时再使用上面提交的 $ git checkout – test.txt 来撤销工作区修改，世界终于变得清净了！</p>
<h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm test2.txt</span><br></pre></td></tr></table></figure>
<p>此命令可以从工作区删掉文件。如果要从版本库中删除，则add后提交即可，如果是误删了，则通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test2.txt</span><br></pre></td></tr></table></figure>
<p>从版本库里恢复。<br>如果已经将删除提交，则像前面一样先恢复版本库，然后在checkout出要恢复的文件。</p>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>##概述</p>
<p>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。这种情况下需要分支来管理。自己在创建的新分支上进行开发，完成后一次性提交合并即可。<br>Git对于分支的创建、切换和删除都能非常快的实现，而SVN就很慢。</p>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>git单分支的结构是这样的，master是指向最新提交的指针，HEAD是指向master的指针，每做一次提交，指针就向前移动一步：</p>
<p><img src="/images/git_2.png"></p>
<p>现在增加一个dev分支并切换到这个分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git -b checkout dev</span><br></pre></td></tr></table></figure>
<p>这个代码可以写成两步，本别是创建新分支 $ git branch dev ，切换到目标分支 $ git checkout dev ，之后变成这样：<br><img src="/images/git_3.png"></p>
<p>这时可以用命令查看分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
<p>其中带星号的是当前所在分支。然后再新分支上做一些更改，再add并提交，这是结构变成了这样：<br><img src="/images/git_4.png"></p>
<p>切换回master（$ git checkout master ）分支后，发现刚才所做的改动不见了，是因为改动在dev分支上。<br><img src="/images/git_5.png"></p>
<p>这时使用合并命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure>
<p>即把目标分支合并到当前分支上。完成后提示 Fast-forward ，说明系统用了快进模式进行合并，此时的结构为：</p>
<p><img src="/images/git_6.png"><br>master分支上也成了最新版。这时不需要dev分支了，可以删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure>
<p>这时再查看分支，已经没有dev了。</p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当两个分支上对同一个文件有修改并分别有提交，最后Git无法自动合并，就会产生冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &#x27;feature2&#x27;</span><br><span class="line">Auto-merging test2.txt</span><br><span class="line">CONFLICT (content): Merge conflict in test2.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<p>如果你不服气再执行一次合并，就会看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature2</span><br><span class="line">error: Merging is not possible because you have unmerged files.</span><br><span class="line">hint: Fix them up in the work tree, and then use &#x27;git add/rm &lt;file&gt;&#x27;</span><br><span class="line">hint: as appropriate to mark resolution and make a commit.</span><br><span class="line">fatal: Exiting because of an unresolved conflict.</span><br></pre></td></tr></table></figure>
<p>这时候可以通过 git status  查看冲突信息，找到描述中冲突的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">f4 in master</span><br><span class="line">=======</span><br><span class="line">f4 is new</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; f4</span><br></pre></td></tr></table></figure>

<p>其中 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 和  =======  之间是当前分支的最新版，  =======  和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; f4  之间是目标分支内容，手动修改后删掉这些符号，然后提交，结构如图：</p>
<p><img src="/images/git_7.png"></p>
<p>可以用以下代码看到图形化流程：<br>$ git log –graph –pretty=oneline –abbrev-commit</p>
<p>其中，  –graph 是图形化，  –pretty=oneline 是一行显示， –abbrev-commit 是只显示每次提交id的前几位，显示效果如下：</p>
<p><img src="/images/git_8.png"></p>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>默认情况下，如果情况允许，Git会自动用快进模式合并分支，但这样合并后不会留下分支存在过的痕迹。删除分支后就会丢失相应信息。如果不想这样做，则在合并时加上参数 –no-ff  ，Git则会生成一个提交，所以同时再加上一个提交信息（如果不加则会进入vim模式让编辑提交信息），代码如下：<br> $ git merge –no-ff -m “merge with no-ff” dev</p>
<p>这样合并后还能看到对应的分支信息，如图，<br><img src="/images/git_9.png"><br>实际开发中的分支策略：<br>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>平时大家在dev分支上干活，需要发布时合并到master分支即可。</p>
<h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>假设正在dev上开发，突然接到修复master上一个bug，就可以用如下命令把现场保存起来（这个命令比其他命令要执行的慢）：<br>$ git stash</p>
<p>这时工作区就是干净的，刚才的改动不见了。然后把分支切换到master，并在此基础上新建并切换到bug分支issue-101，在这里修复bug。修复完成后回到master分支，进行非快速合并后删除bug分支，再切换回dev分支，可以通过加list参数看到 stash 的列表：<br>$ git stash list<br>stash@{0}: WIP on d3: 820373a 合并d2, Merge branch ‘d2’</p>
<p>通过如下命令恢复现场：<br>$ git stash apply</p>
<p>这时stash区的内容还存在，可以用list查看，如果要清理掉，就用<br>$ git stash drop</p>
<p>这时stash区什么都没了。如果将工作区内容多次保存到stash，则可以加 stash@{0} 这样的编号来指定恢复哪个（可用list参数查看编号）。<br>$ git stash apply stash@{0}</p>
<p>也可以用如下命令弹出最后一次保存的工作区内容，这个命令会将对应的stash内容清除掉。<br>$ git stash pop</p>
<h2 id="Feature分支——强行删除分支"><a href="#Feature分支——强行删除分支" class="headerlink" title="Feature分支——强行删除分支"></a>Feature分支——强行删除分支</h2><p>如果在master分支上删除一个已经提交但没有合并的其它分支，则会报错：<br>$ git branch -d f5<br>error: The branch ‘f5’ is not fully merged.<br>If you are sure you want to delete it, run ‘git branch -D f5’.</p>
<p>这时可以用参数 -D 强制删除：<br>$ git branch -D f5</p>
<p>需要注意的是，由于分支未合并，删除之后就没有任何记录了，分支上所有的修改也会丢失。</p>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>先来两个命令：<br>$ git remote</p>
<p>查看远程仓库名称<br>$ git remote -v</p>
<p>查看远程仓库更详细的信息<br>场景：我本地有master和dev两个分支，但我只把master推送到远程仓库中。然后我的小伙伴从远程的master分支上克隆了一份，他是看不到我本地dev分支的。然后自己在本地新建dev分支进行开发，完了之后推送到远程仓库。同时我在本地 的dev分支修改了跟他一样的文件。这时我准备推送代码，就会报错，提示先pull同步代码， 但拉取的时候又报错，说没有指定本地dev和远程origin/dev之间的连接（ There is no tracking information for the current branch. ）。可通过以下代码进行关联：<br>$ git branch –set-upstream-to=origin/dev dev</p>
<p>然后再pull，解决冲突，再提交，再push，跟前面一样。</p>
<p>补充 ：从远程git仓库里的指定分支拉取到本地（本地不存在的分支）<br>git checkout -b 本地分支名 origin/远程分支名</p>
<p>然后再 pull </p>
<h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2><p>Rebase用来整理提交记录，把多条分叉合并成一条直线。</p>
<p>假设有代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 582d922 (HEAD -&gt; master) add author</span><br><span class="line">* 8875536 add comment</span><br><span class="line">* d1be385 (origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。假设推送时发现有人改了同样文件导致冲突，pull下来解决后再提交，这时本地分支会比远程超前3个提交。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch &#x27;master&#x27; of github.com:michaelliao/learngit</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) set exit=1</span><br><span class="line">* | 582d922 add author</span><br><span class="line">* | 8875536 add comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br></pre></td></tr></table></figure>

<p>如果觉得这种分叉的图形看起来乱，可以用如下命令整理一下：<br>$ git rebase</p>
<p>整理后查看到的记录为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin/master) set exit=1</span><br><span class="line">* d1be385 init hello</span><br></pre></td></tr></table></figure>

<p>发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。推送之后如图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 set exit=1</span><br><span class="line">* d1be385 init hello</span><br></pre></td></tr></table></figure>

<p>远程和本地都成了一条直线。<br>Rebase的缺点是会更改我们的本地提交，但合并后的内容是一致的。</p>
<h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>Git的标签就是版本库的快照，但其实它就是指向某个commit的指针。</p>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure>

<p>给当前的commit打上标签 v1.0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure>

<p>查看所有标签，经测试在dev分支上能看到master上所有标签，尽管dev上面的commit要少很多。<br>注意，标签不是按时间顺序列出，而是按字母排序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure>

<p>可以给历史commit打上标签，最后一个参数是commit的前几位（通过git log查看）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure>

<p>创建带有注释的标签，-a后面是标签名，-m后面是注释内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.1</span><br></pre></td></tr></table></figure>

<p>查看标签名为 v0.1的详细内容</p>
<h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br></pre></td></tr></table></figure>

<p>删除本地标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br></pre></td></tr></table></figure>
<p>将标签 v1.0 推送到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure>
<p>将尚未推送的标签全部推送到远程仓库<br>如果要删除远程仓库的标签，有以下两个步骤：</p>
<ul>
<li>删除本地标签，见上</li>
<li>删除远程仓库对应标签 $ git push origin :refs/tags/v0.9</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/03/git%E5%9F%BA%E7%A1%80/" data-id="ckw8thuju0011e4d8hwmu5ual" data-title="git基础" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ngnix/">Ngnix</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ajax/">ajax</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cache/">cache</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css2-1/">css2.1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/funny/">funny</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/memory/">memory</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project/">project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storage/">storage</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/utils/">utils</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue2-x/">vue2.x</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E4%BA%AB/" rel="tag">分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag">导航</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%88%86%E4%BA%AB/" style="font-size: 10px;">分享</a> <a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 10px;">导航</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/07/02/%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%85%BC%E5%AE%B9/">软件的兼容</a>
          </li>
        
          <li>
            <a href="/2019/09/09/webpack%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/">webpack异步加载组件原理.md</a>
          </li>
        
          <li>
            <a href="/2019/09/09/%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD/">组件的按需加载</a>
          </li>
        
          <li>
            <a href="/2019/09/06/%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型链</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>